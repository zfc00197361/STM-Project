.TH "main.cpp" 3 "Sun Apr 1 2018" "C++ Software transactional Memory" \" -*- nroff -*-
.ad l
.nh
.SH NAME
main.cpp \- 
.SH SYNOPSIS
.br
.PP
\fC#include <cstdlib>\fP
.br
\fC#include <iostream>\fP
.br
\fC#include <thread>\fP
.br
\fC#include 'TM\&.h'\fP
.br
\fC#include 'AIB\&.h'\fP
.br
\fC#include 'BOI\&.h'\fP
.br
\fC#include 'BOA\&.h'\fP
.br
\fC#include 'SWBPLC\&.h'\fP
.br
\fC#include 'ULSTER\&.h'\fP
.br
\fC#include 'UNBL\&.h'\fP
.br
\fC#include 'WAREHOUSE\&.h'\fP
.br
\fC#include 'CARPHONE_WAREHOUSE\&.h'\fP
.br
\fC#include 'CARLOW_W\&.h'\fP
.br
\fC#include 'KILKENNY_W\&.h'\fP
.br
\fC#include 'TALLAGH_W\&.h'\fP
.br
\fC#include 'DUNDALK_W\&.h'\fP
.br
\fC#include 'SLIGO_W\&.h'\fP
.br
\fC#include <mutex>\fP
.br
\fC#include <memory>\fP
.br
\fC#include <condition_variable>\fP
.br
\fC#include <vector>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fB_complex_transfer_\fP (std::shared_ptr< \fBOSTM\fP > _from_, std::shared_ptr< \fBOSTM\fP > _from_two_, std::vector< std::shared_ptr< \fBOSTM\fP >> _customer_vec, \fBTM\fP &_tm, double _amount)"
.br
.RI "\fI\fIcomplex_transfer\fP function, takes two std::shared_ptr<OSTM> pointer, a vector of std::shared_ptr<OSTM> pointers, the Transaction manager, and the amount to use in the transaction, and transfer the _amount value from booth single objects to the objects to the vector collection \fP"
.ti -1c
.RI "void \fB_complex_warehouse_transfer_\fP (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _to_two, std::shared_ptr< \fBOSTM\fP > _to_three, std::vector< std::shared_ptr< \fBOSTM\fP >> _warehouse_vec, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP &_tm, double _amount)"
.br
.ti -1c
.RI "void \fB_nested_warehouse_transfer_\fP (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _to_two, std::shared_ptr< \fBOSTM\fP > _to_three, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP &_tm, double _amount)"
.br
.RI "\fI\fInested_warehouse_transfer\fP function, takes three std::shared_ptr<OSTM> pointer, the Transaction manager, and the amount to use in the transaction and transfer the _amount value from one account to the another account \fP"
.ti -1c
.RI "void \fB_nesting_\fP (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP &_tm, double _amount)"
.br
.RI "\fI\fInesting\fP function, takes two std::shared_ptr<OSTM> pointer, the Transaction manager, and the amount to use in the transaction and transfer the _amount value from one account to the another account This function create nested transactions inside the transaction, and call other function to nesting the transaction as well \fP"
.ti -1c
.RI "void \fB_six_account_transfer_\fP (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_one_, std::shared_ptr< \fBOSTM\fP > _from_two_, std::shared_ptr< \fBOSTM\fP > _from_three_, std::shared_ptr< \fBOSTM\fP > _from_four_, std::shared_ptr< \fBOSTM\fP > _from_five_, \fBTM\fP &_tm, double _amount)"
.br
.RI "\fI\fIsix_account_transfer\fP function, takes six std::shared_ptr<OSTM> pointer, the Transaction manager, and the amount to use in the transaction and transfer the _amount value from five account to one account \fP"
.ti -1c
.RI "void \fB_two_account_transfer_\fP (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP &_tm, double _amount)"
.br
.RI "\fI\fItwo_account_transfer\fP function, takes two std::shared_ptr<OSTM> pointer, the Transaction manager, and the amount to use in the transaction and transfer the _amount value from one account to the another account \fP"
.ti -1c
.RI "void \fB_warehouse_transfer_\fP (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP &_tm, double _amount)"
.br
.RI "\fI\fIwarehouse_transfer\fP function, takes two std::shared_ptr<OSTM> pointer, the Transaction manager, and the amount to use in the transaction and transfer the _amount value from one account to the another account \fP"
.ti -1c
.RI "int \fBmain\fP (void)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static int \fBvector_number\fP = 600"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void _complex_transfer_ (std::shared_ptr< \fBOSTM\fP > _from_, std::shared_ptr< \fBOSTM\fP > _from_two_, std::vector< std::shared_ptr< \fBOSTM\fP >> _customer_vec, \fBTM\fP & _tm, double _amount)"

.PP
\fIcomplex_transfer\fP function, takes two std::shared_ptr<OSTM> pointer, a vector of std::shared_ptr<OSTM> pointers, the Transaction manager, and the amount to use in the transaction, and transfer the _amount value from booth single objects to the objects to the vector collection 
.PP
\fBParameters:\fP
.RS 4
\fIstd::shared_ptr<TX>\fP tx, Transaction Object 
.br
\fIstd::shared_ptr<BANK>\fP type, \fIFROM\fP & \fIFROM_TWO\fP & \fITO\fP 
.br
\fIstd::shared_ptr<OSTM>\fP type, \fIFROM_OSTM_ONE\fP & \fIFROM_OSTM_TWO\fP & \fITO_OSTM\fP 
.RE
.PP
Register the two single account
.PP
Declare required pointers
.PP
Register customers accounts from the collection (vector)
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
Commit changes
.PP
Definition at line 294 of file main\&.cpp\&.
.PP
References TM::_get_tx(), and BANK::SetBalance()\&.
.PP
.nf
294                                                                                                                                                            {
295     std::shared_ptr<TX> tx = _tm\&._get_tx();
299     tx->_register(_from_);
300     tx->_register(_from_two_);
304     std::shared_ptr<OSTM> _FROM_OSTM_ONE_, _FROM_OSTM_TWO_, _TO_OSTM_;
305     std::shared_ptr<BANK> _FROM_, _FROM_TWO_, _TO_;
306 
307     bool done = false;
308     try {
309         while (!done) {
310             // for (int i = 0; i < vector_number; ++i) {
311             for (auto&& obj : _customer_vec) {
315                 // auto&& obj = _customer_vec\&.at(i);
316                 tx->_register(obj);
320                 _FROM_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_));
321                 _FROM_TWO_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_two_));
322                 _TO_ = std::dynamic_pointer_cast<BANK> (tx->load(obj));
326                 _FROM_->SetBalance(_FROM_->GetBalance() - _amount);
327                 _FROM_TWO_->SetBalance(_FROM_TWO_->GetBalance() - _amount);
328                 _TO_->SetBalance(_TO_->GetBalance() + (_amount * 2));
332                 _FROM_OSTM_ONE_ = std::dynamic_pointer_cast<OSTM> (_FROM_);
333                 _FROM_OSTM_TWO_ = std::dynamic_pointer_cast<OSTM> (_FROM_TWO_);
334                 _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_);
338                 tx->store(_FROM_OSTM_ONE_);
339                 tx->store(_FROM_OSTM_TWO_);
340                 tx->store(_TO_OSTM_);
341             }
345             done = tx->commit();
346         }
347     } catch (std::runtime_error& e) {
348         std::cout << e\&.what() << std::endl;
349     }
350 }
.fi
.SS "void _complex_warehouse_transfer_ (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _to_two, std::shared_ptr< \fBOSTM\fP > _to_three, std::vector< std::shared_ptr< \fBOSTM\fP >> _warehouse_vec, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP & _tm, double _amount)"
Register the two single account
.PP
Declare required pointers
.PP
Register customers accounts from the collection (vector)
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<WAREHOUSE> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
NESTED \fBWAREHOUSE\fP TEST _to_two
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
Commit changes
.PP
Definition at line 518 of file main\&.cpp\&.
.PP
References TM::_get_tx(), _nested_warehouse_transfer_(), _warehouse_transfer_(), and WAREHOUSE::SetNumber_of_nokia()\&.
.PP
.nf
518                                                                                                                                                                                                                             {
519     std::shared_ptr<TX> tx = _tm\&._get_tx();
523     tx->_register(_to_);
524     tx->_register(_to_two);
525     tx->_register(_to_three);
526     tx->_register(_from_);
530     std::shared_ptr<WAREHOUSE> _TO_SHOP_, _TO_SHOP_TWO, _TO_SHOP_VEC, _FROM_DIST_;
531     std::shared_ptr<OSTM> _TO_OSTM_, _TO_OSTM_TWO, _TO_OSTM_VEC, _FROM_OSTM_;
532 
533     bool done = false;
534     try {
535         while (!done) {
536 
537             // for (int i = 0; i < vector_number; ++i) {
538             for (auto&& obj : _warehouse_vec) {
542                 //auto&& obj = _warehouse_vec\&.at(i);
543                 tx->_register(obj);
547                 _TO_SHOP_ = std::dynamic_pointer_cast<WAREHOUSE> (tx->load(_to_));
548                 _TO_SHOP_TWO = std::dynamic_pointer_cast<WAREHOUSE> (tx->load(_to_two));
549                 _TO_SHOP_VEC = std::dynamic_pointer_cast<WAREHOUSE> (tx->load(obj));
550                 _FROM_DIST_ = std::dynamic_pointer_cast<WAREHOUSE> (tx->load(_from_));
551 
555                 _TO_SHOP_->SetNumber_of_nokia(_TO_SHOP_->GetNumber_of_nokia() + _amount);
556                 _TO_SHOP_TWO->SetNumber_of_nokia(_TO_SHOP_TWO->GetNumber_of_nokia() + _amount);
557                 _TO_SHOP_VEC->SetNumber_of_nokia(_TO_SHOP_VEC->GetNumber_of_nokia() + _amount);
558                 _FROM_DIST_->SetNumber_of_nokia(_FROM_DIST_->GetNumber_of_nokia() - (_amount * 3));
559 
560                 _TO_SHOP_->SetNumber_of_samsung(_TO_SHOP_->GetNumber_of_samsung() + _amount);
561                 _TO_SHOP_TWO->SetNumber_of_samsung(_TO_SHOP_TWO->GetNumber_of_samsung() + _amount);
562                 _TO_SHOP_VEC->SetNumber_of_samsung(_TO_SHOP_VEC->GetNumber_of_samsung() + _amount);
563                 _FROM_DIST_->SetNumber_of_samsung(_FROM_DIST_->GetNumber_of_samsung() - (_amount * 3));
564 
565                 _TO_SHOP_->SetNumber_of_iphones(_TO_SHOP_->GetNumber_of_iphones() + _amount);
566                 _TO_SHOP_TWO->SetNumber_of_iphones(_TO_SHOP_TWO->GetNumber_of_iphones() + _amount);
567                 _TO_SHOP_VEC->SetNumber_of_iphones(_TO_SHOP_VEC->GetNumber_of_iphones() + _amount);
568                 _FROM_DIST_->SetNumber_of_iphones(_FROM_DIST_->GetNumber_of_iphones() - (_amount * 3));
569 
570                 _TO_SHOP_->SetNumber_of_sony(_TO_SHOP_->GetNumber_of_sony() + _amount);
571                 _TO_SHOP_TWO->SetNumber_of_sony(_TO_SHOP_TWO->GetNumber_of_sony() + _amount);
572                 _TO_SHOP_VEC->SetNumber_of_sony(_TO_SHOP_VEC->GetNumber_of_sony() + _amount);
573                 _FROM_DIST_->SetNumber_of_sony(_FROM_DIST_->GetNumber_of_sony() - (_amount * 3));
574 
578                 _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_SHOP_);
579                 _TO_OSTM_TWO = std::dynamic_pointer_cast<OSTM> (_TO_SHOP_TWO);
580                 _TO_OSTM_VEC = std::dynamic_pointer_cast<OSTM> (_TO_SHOP_VEC);
581                 _FROM_OSTM_ = std::dynamic_pointer_cast<OSTM> (_FROM_DIST_);
585                 tx->store(_TO_OSTM_);
586                 tx->store(_TO_SHOP_TWO);
587                 tx->store(_TO_SHOP_VEC);
588                 tx->store(_FROM_OSTM_);
589 
590 
591 
592             }
596             std::shared_ptr<TX> txTwo = _tm\&._get_tx();
597             bool nestedDone = false;
598             while (!nestedDone) {
599                 _TO_SHOP_ = std::dynamic_pointer_cast<WAREHOUSE> (txTwo->load(_to_two));
600                 _FROM_DIST_ = std::dynamic_pointer_cast<WAREHOUSE> (txTwo->load(_from_));
604                 _TO_SHOP_->SetNumber_of_nokia(_TO_SHOP_->GetNumber_of_nokia() + _amount);
605                 _FROM_DIST_->SetNumber_of_nokia(_FROM_DIST_->GetNumber_of_nokia() - _amount);
606 
607                 _TO_SHOP_->SetNumber_of_samsung(_TO_SHOP_->GetNumber_of_samsung() + _amount);
608                 _FROM_DIST_->SetNumber_of_samsung(_FROM_DIST_->GetNumber_of_samsung() - _amount);
609 
610                 _TO_SHOP_->SetNumber_of_iphones(_TO_SHOP_->GetNumber_of_iphones() + _amount);
611                 _FROM_DIST_->SetNumber_of_iphones(_FROM_DIST_->GetNumber_of_iphones() - _amount);
612 
613                 _TO_SHOP_->SetNumber_of_sony(_TO_SHOP_->GetNumber_of_sony() + _amount);
614                 _FROM_DIST_->SetNumber_of_sony(_FROM_DIST_->GetNumber_of_sony() - _amount);
618                 _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_SHOP_);
619                 _FROM_OSTM_ = std::dynamic_pointer_cast<OSTM> (_FROM_DIST_);
623                 txTwo->store(_TO_OSTM_);
624                 txTwo->store(_FROM_OSTM_);
625 
626                 /*
627                  * NESTED TRANSACTION TEST _to_three
628                  */
629                 _warehouse_transfer_(_to_three, _from_, _tm, _amount);
630                 _nested_warehouse_transfer_(_to_, _to_two, _to_three, _from_, _tm, _amount);
631 
632                 nestedDone = tx->commit();
633             }
634 
638             done = tx->commit();
639 
640         }
641     } catch (std::runtime_error& e) {
642         std::cout << e\&.what() << std::endl;
643     }
644 }
.fi
.SS "void _nested_warehouse_transfer_ (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _to_two, std::shared_ptr< \fBOSTM\fP > _to_three, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP & _tm, double _amount)"

.PP
\fInested_warehouse_transfer\fP function, takes three std::shared_ptr<OSTM> pointer, the Transaction manager, and the amount to use in the transaction and transfer the _amount value from one account to the another account 
.PP
\fBParameters:\fP
.RS 4
\fIstd::shared_ptr<TX>\fP tx, Transaction Object 
.br
\fIstd::shared_ptr<WAREHOUSE>\fP type, \fITO_SHOP\fP & \fIFROM_DIST\fP 
.br
\fIstd::shared_ptr<OSTM>\fP type, \fITO_OSTM\fP & \fIFROM_OSTM\fP 
.RE
.PP
Register the two single account
.PP
Declare required pointers
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
NESTED \fBWAREHOUSE\fP TEST _to_two
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
Commit changes
.PP
Definition at line 419 of file main\&.cpp\&.
.PP
References TM::_get_tx(), _warehouse_transfer_(), and WAREHOUSE::SetNumber_of_nokia()\&.
.PP
Referenced by _complex_warehouse_transfer_()\&.
.PP
.nf
419                                                                                                                                                                             {
420     std::shared_ptr<TX> tx = _tm\&._get_tx();
424     tx->_register(_to_);
425     tx->_register(_to_two);
426     tx->_register(_to_three);
427     tx->_register(_from_);
431     std::shared_ptr<WAREHOUSE> _TO_SHOP_, _FROM_DIST_;
432     std::shared_ptr<OSTM> _TO_OSTM_, _FROM_OSTM_;
433 
434     bool done = false;
435     try {
436         while (!done) {
440             _TO_SHOP_ = std::dynamic_pointer_cast<WAREHOUSE> (tx->load(_to_));
441             _FROM_DIST_ = std::dynamic_pointer_cast<WAREHOUSE> (tx->load(_from_));
445             _TO_SHOP_->SetNumber_of_nokia(_TO_SHOP_->GetNumber_of_nokia() + _amount);
446             _FROM_DIST_->SetNumber_of_nokia(_FROM_DIST_->GetNumber_of_nokia() - _amount);
447 
448             _TO_SHOP_->SetNumber_of_samsung(_TO_SHOP_->GetNumber_of_samsung() + _amount);
449             _FROM_DIST_->SetNumber_of_samsung(_FROM_DIST_->GetNumber_of_samsung() - _amount);
450 
451             _TO_SHOP_->SetNumber_of_iphones(_TO_SHOP_->GetNumber_of_iphones() + _amount);
452             _FROM_DIST_->SetNumber_of_iphones(_FROM_DIST_->GetNumber_of_iphones() - _amount);
453 
454             _TO_SHOP_->SetNumber_of_sony(_TO_SHOP_->GetNumber_of_sony() + _amount);
455             _FROM_DIST_->SetNumber_of_sony(_FROM_DIST_->GetNumber_of_sony() - _amount);
459             _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_SHOP_);
460             _FROM_OSTM_ = std::dynamic_pointer_cast<OSTM> (_FROM_DIST_);
464             tx->store(_TO_OSTM_);
465             tx->store(_FROM_OSTM_);
466 
470             std::shared_ptr<TX> txTwo = _tm\&._get_tx();
471             bool nestedDone = false;
472             while (!nestedDone) {
473                 _TO_SHOP_ = std::dynamic_pointer_cast<WAREHOUSE> (txTwo->load(_to_two));
474                 _FROM_DIST_ = std::dynamic_pointer_cast<WAREHOUSE> (txTwo->load(_from_));
478                 _TO_SHOP_->SetNumber_of_nokia(_TO_SHOP_->GetNumber_of_nokia() + _amount);
479                 _FROM_DIST_->SetNumber_of_nokia(_FROM_DIST_->GetNumber_of_nokia() - _amount);
480 
481                 _TO_SHOP_->SetNumber_of_samsung(_TO_SHOP_->GetNumber_of_samsung() + _amount);
482                 _FROM_DIST_->SetNumber_of_samsung(_FROM_DIST_->GetNumber_of_samsung() - _amount);
483 
484                 _TO_SHOP_->SetNumber_of_iphones(_TO_SHOP_->GetNumber_of_iphones() + _amount);
485                 _FROM_DIST_->SetNumber_of_iphones(_FROM_DIST_->GetNumber_of_iphones() - _amount);
486 
487                 _TO_SHOP_->SetNumber_of_sony(_TO_SHOP_->GetNumber_of_sony() + _amount);
488                 _FROM_DIST_->SetNumber_of_sony(_FROM_DIST_->GetNumber_of_sony() - _amount);
492                 _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_SHOP_);
493                 _FROM_OSTM_ = std::dynamic_pointer_cast<OSTM> (_FROM_DIST_);
497                 txTwo->store(_TO_OSTM_);
498                 txTwo->store(_FROM_OSTM_);
499 
500                 /*
501                  * NESTED TRANSACTION TEST _to_three
502                  */
503                 _warehouse_transfer_(_to_three, _from_, _tm, _amount);
504 
505 
506                 nestedDone = tx->commit();
507             }
511             done = tx->commit();
512         }
513     } catch (std::runtime_error& e) {
514         std::cout << e\&.what() << std::endl;
515     }
516 }
.fi
.SS "void _nesting_ (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP & _tm, double _amount)"

.PP
\fInesting\fP function, takes two std::shared_ptr<OSTM> pointer, the Transaction manager, and the amount to use in the transaction and transfer the _amount value from one account to the another account This function create nested transactions inside the transaction, and call other function to nesting the transaction as well 
.PP
\fBParameters:\fP
.RS 4
\fIstd::shared_ptr<TX>\fP tx, Transaction Object 
.br
\fIstd::shared_ptr<BANK>\fP type, \fITO_BANK\fP & \fIFROM_BANK\fP 
.br
\fIstd::shared_ptr<OSTM>\fP type, \fITO_OSTM\fP & \fIFROM_OSTM\fP 
.RE
.PP
Register the two single account
.PP
Declare required pointers
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
NESTED TRANSACTION
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
NESTED TRANSACTION IN THE NESTED TRANSACTION \fItwo_account_transfer\fP function call
.PP
Commit changes
.PP
Definition at line 206 of file main\&.cpp\&.
.PP
References TM::_get_tx(), _two_account_transfer_(), and BANK::SetBalance()\&.
.PP
Referenced by main()\&.
.PP
.nf
206                                                                                               {
207     std::shared_ptr<TX> tx = _tm\&._get_tx();
211     tx->_register(_to_);
212     tx->_register(_from_);
216     std::shared_ptr<BANK> _TO_BANK_, _FROM_BANK_;
217     std::shared_ptr<OSTM> _TO_OSTM_, _FROM_OSTM_;
218 
219 
220     bool done = false;
221     try {
222         while (!done) {
226             _TO_BANK_ = std::dynamic_pointer_cast<BANK> (tx->load(_to_));
227             _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_));
231             _TO_BANK_->SetBalance(_TO_BANK_->GetBalance() + _amount);
232             _FROM_BANK_->SetBalance(_FROM_BANK_->GetBalance() - _amount);
236             _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_BANK_);
237             _FROM_OSTM_ = std::dynamic_pointer_cast<OSTM> (_FROM_BANK_);
241             tx->store(_TO_OSTM_);
242             tx->store(_FROM_OSTM_);
243 
247             std::shared_ptr<TX> txTwo = _tm\&._get_tx();
248 
249             bool nestedDone = false;
250             while (!nestedDone) {
251                 _TO_BANK_ = std::dynamic_pointer_cast<BANK> (txTwo->load(_to_));
252                 _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (txTwo->load(_from_));
256                 _TO_BANK_->SetBalance(_TO_BANK_->GetBalance() + _amount);
257                 _FROM_BANK_->SetBalance(_FROM_BANK_->GetBalance() - _amount);
261                 _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_BANK_);
262                 _FROM_OSTM_ = std::dynamic_pointer_cast<OSTM> (_FROM_BANK_);
266                 txTwo->store(_TO_OSTM_);
267                 txTwo->store(_FROM_OSTM_);
272                 _two_account_transfer_(_to_, _from_, _tm, _amount);
273 
274                 nestedDone = txTwo->commit();
275             }
276 
280             done = tx->commit();
281         }
282     } catch (std::runtime_error& e) {
283         std::cout << e\&.what() << std::endl;
284     }
285 }
.fi
.SS "void _six_account_transfer_ (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_one_, std::shared_ptr< \fBOSTM\fP > _from_two_, std::shared_ptr< \fBOSTM\fP > _from_three_, std::shared_ptr< \fBOSTM\fP > _from_four_, std::shared_ptr< \fBOSTM\fP > _from_five_, \fBTM\fP & _tm, double _amount)"

.PP
\fIsix_account_transfer\fP function, takes six std::shared_ptr<OSTM> pointer, the Transaction manager, and the amount to use in the transaction and transfer the _amount value from five account to one account 
.PP
\fBParameters:\fP
.RS 4
\fIstd::shared_ptr<TX>\fP tx, Transaction Object 
.br
\fIstd::shared_ptr<BANK>\fP type, \fITO\fP & \fIFROM_ONE\fP & \fIFROM_TWO\fP & \fIFROM_THREE\fP & \fIFROM_FOUR\fP & \fIFROM_FIVE\fP 
.br
\fIstd::shared_ptr<OSTM>\fP type, _TO_OSTM & _FROM_ONE_OSTM & _FROM_TWO_OSTM & _FROM_THREE_OSTM & _FROM_FOUR_OSTM & _FROM_FIVE_OSTM 
.RE
.PP
Register the two single account
.PP
Required pointers to use in transaction
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
Commit changes
.PP
Definition at line 51 of file main\&.cpp\&.
.PP
References TM::_get_tx(), and BANK::SetBalance()\&.
.PP
.nf
51                                                                                                                                                                                                                                                    {
52     std::shared_ptr<TX> tx = _tm\&._get_tx();
56     tx->_register(_to_);
57     tx->_register(_from_one_);
58     tx->_register(_from_two_);
59     tx->_register(_from_three_);
60     tx->_register(_from_four_);
61     tx->_register(_from_five_);
62 
66     std::shared_ptr<OSTM> _TO_OSTM, _FROM_ONE_OSTM, _FROM_TWO_OSTM, _FROM_THREE_OSTM, _FROM_FOUR_OSTM, _FROM_FIVE_OSTM;
67     std::shared_ptr<BANK> _TO_, _FROM_ONE_, _FROM_TWO_, _FROM_THREE_, _FROM_FOUR_, _FROM_FIVE_;
68     try {
69         bool done = false;
70         while (!done) {
74             _TO_ = std::dynamic_pointer_cast<BANK> (tx->load(_to_));
75             _FROM_ONE_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_one_));
76             _FROM_TWO_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_two_));
77             _FROM_THREE_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_three_));
78             _FROM_FOUR_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_four_));
79             _FROM_FIVE_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_five_));
83             _TO_->SetBalance(_TO_->GetBalance() + (_amount * 5));
84             _FROM_ONE_->SetBalance(_FROM_ONE_->GetBalance() - _amount);
85             _FROM_TWO_->SetBalance(_FROM_TWO_->GetBalance() - _amount);
86             _FROM_THREE_->SetBalance(_FROM_THREE_->GetBalance() - _amount);
87             _FROM_FOUR_->SetBalance(_FROM_FOUR_->GetBalance() - _amount);
88             _FROM_FIVE_->SetBalance(_FROM_FIVE_->GetBalance() - _amount);
92             _TO_OSTM = std::dynamic_pointer_cast<OSTM> (_TO_);
93             _FROM_ONE_OSTM = std::dynamic_pointer_cast<OSTM> (_FROM_ONE_);
94             _FROM_TWO_OSTM = std::dynamic_pointer_cast<OSTM> (_FROM_TWO_);
95             _FROM_THREE_OSTM = std::dynamic_pointer_cast<OSTM> (_FROM_THREE_);
96             _FROM_FOUR_OSTM = std::dynamic_pointer_cast<OSTM> (_FROM_FOUR_);
97             _FROM_FIVE_OSTM = std::dynamic_pointer_cast<OSTM> (_FROM_FIVE_);
101             tx->store(_TO_OSTM);
102             tx->store(_FROM_ONE_OSTM);
103             tx->store(_FROM_TWO_OSTM);
104             tx->store(_FROM_THREE_OSTM);
105             tx->store(_FROM_FOUR_OSTM);
106             tx->store(_FROM_FIVE_OSTM);
110             done = tx->commit();
111         }
112     } catch (std::runtime_error& e) {
113         std::cout << e\&.what() << std::endl;
114     }
115 }
.fi
.SS "void _two_account_transfer_ (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP & _tm, double _amount)"

.PP
\fItwo_account_transfer\fP function, takes two std::shared_ptr<OSTM> pointer, the Transaction manager, and the amount to use in the transaction and transfer the _amount value from one account to the another account 
.PP
\fBParameters:\fP
.RS 4
\fIstd::shared_ptr<TX>\fP tx, Transaction Object 
.br
\fIstd::shared_ptr<BANK>\fP type, \fITO_BANK\fP & \fIFROM_BANK\fP 
.br
\fIstd::shared_ptr<OSTM>\fP type, \fITO_OSTM\fP & \fIFROM_OSTM\fP 
.RE
.PP
Register the two single account
.PP
Declare required pointers
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
NESTED TRANSACTION
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
Commit changes
.PP
Commit changes
.PP
Definition at line 123 of file main\&.cpp\&.
.PP
References TM::_get_tx(), and BANK::SetBalance()\&.
.PP
Referenced by _nesting_()\&.
.PP
.nf
123                                                                                                            {
124     std::shared_ptr<TX> tx = _tm\&._get_tx();
128     tx->_register(_to_);
129     tx->_register(_from_);
133     std::shared_ptr<BANK> _TO_BANK_, _FROM_BANK_;
134     std::shared_ptr<OSTM> _TO_OSTM_, _FROM_OSTM_;
135 
136     bool done = false;
137     try {
138         while (!done) {
142             _TO_BANK_ = std::dynamic_pointer_cast<BANK> (tx->load(_to_));
143             _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_));
147             _TO_BANK_->SetBalance(_TO_BANK_->GetBalance() + _amount);
148             _FROM_BANK_->SetBalance(_FROM_BANK_->GetBalance() - _amount);
152             _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_BANK_);
153             _FROM_OSTM_ = std::dynamic_pointer_cast<OSTM> (_FROM_BANK_);
157             tx->store(_TO_OSTM_);
158             tx->store(_FROM_OSTM_);
159 
163             std::shared_ptr<TX> txTwo = _tm\&._get_tx();
164 
165             bool nestedDone = false;
166             while (!nestedDone) {
167                 _TO_BANK_ = std::dynamic_pointer_cast<BANK> (txTwo->load(_to_));
168                 _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (txTwo->load(_from_));
172                 _TO_BANK_->SetBalance(_TO_BANK_->GetBalance() + _amount);
173                 _FROM_BANK_->SetBalance(_FROM_BANK_->GetBalance() - _amount);
177                 _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_BANK_);
178                 _FROM_OSTM_ = std::dynamic_pointer_cast<OSTM> (_FROM_BANK_);
182                 txTwo->store(_TO_OSTM_);
183                 txTwo->store(_FROM_OSTM_);
187                 nestedDone = txTwo->commit();
188             }
192             done = tx->commit();
193         }
194     } catch (std::runtime_error& e) {
195         std::cout << e\&.what() << std::endl;
196     }
197 }
.fi
.SS "void _warehouse_transfer_ (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP & _tm, double _amount)"

.PP
\fIwarehouse_transfer\fP function, takes two std::shared_ptr<OSTM> pointer, the Transaction manager, and the amount to use in the transaction and transfer the _amount value from one account to the another account 
.PP
\fBParameters:\fP
.RS 4
\fIstd::shared_ptr<TX>\fP tx, Transaction Object 
.br
\fIstd::shared_ptr<WAREHOUSE>\fP type, \fITO_SHOP\fP & \fIFROM_DIST\fP 
.br
\fIstd::shared_ptr<OSTM>\fP type, \fITO_OSTM\fP & \fIFROM_OSTM\fP 
.RE
.PP
Register the two single account
.PP
Declare required pointers
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
Commit changes
.PP
Definition at line 358 of file main\&.cpp\&.
.PP
References TM::_get_tx(), and WAREHOUSE::SetNumber_of_nokia()\&.
.PP
Referenced by _complex_warehouse_transfer_(), and _nested_warehouse_transfer_()\&.
.PP
.nf
358                                                                                                          {
359     std::shared_ptr<TX> tx = _tm\&._get_tx();
363     tx->_register(_to_);
364     tx->_register(_from_);
368     std::shared_ptr<WAREHOUSE> _TO_SHOP_, _FROM_DIST_;
369     std::shared_ptr<OSTM> _TO_OSTM_, _FROM_OSTM_;
370 
371     bool done = false;
372     try {
373         while (!done) {
377             _TO_SHOP_ = std::dynamic_pointer_cast<WAREHOUSE> (tx->load(_to_));
378             _FROM_DIST_ = std::dynamic_pointer_cast<WAREHOUSE> (tx->load(_from_));
382             _TO_SHOP_->SetNumber_of_nokia(_TO_SHOP_->GetNumber_of_nokia() + _amount);
383             _FROM_DIST_->SetNumber_of_nokia(_FROM_DIST_->GetNumber_of_nokia() - _amount);
384 
385             _TO_SHOP_->SetNumber_of_samsung(_TO_SHOP_->GetNumber_of_samsung() + _amount);
386             _FROM_DIST_->SetNumber_of_samsung(_FROM_DIST_->GetNumber_of_samsung() - _amount);
387 
388             _TO_SHOP_->SetNumber_of_iphones(_TO_SHOP_->GetNumber_of_iphones() + _amount);
389             _FROM_DIST_->SetNumber_of_iphones(_FROM_DIST_->GetNumber_of_iphones() - _amount);
390 
391             _TO_SHOP_->SetNumber_of_sony(_TO_SHOP_->GetNumber_of_sony() + _amount);
392             _FROM_DIST_->SetNumber_of_sony(_FROM_DIST_->GetNumber_of_sony() - _amount);
396             _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_SHOP_);
397             _FROM_OSTM_ = std::dynamic_pointer_cast<OSTM> (_FROM_DIST_);
401             tx->store(_TO_OSTM_);
402             tx->store(_FROM_OSTM_);
406             done = tx->commit();
407         }
408     } catch (std::runtime_error& e) {
409         std::cout << e\&.what() << std::endl;
410     }
411 }
.fi
.SS "int main (void)"
main method to run test Get the Transaction Manager
.br
 \fBTM\fP& tm = \fBTM::Instance()\fP;
.br
.PP
Create vector to store std::shared_ptr<OSTM> pointers\&. All object will have unique ID by default
.br
 std::vector<std::shared_ptr<OSTM>> _customer_vec(vector_number);
.br
 std::vector<std::shared_ptr<OSTM>> _warehouse_vec(vector_number);
.br
.PP
Create objects type of \fBBANK\fP\&. All object will have unique ID by default
.br
 std::shared_ptr<OSTM> aib_ptr = new \fBAIB\fP(100, 500, 'Joe', 'Blog', 'High street, Kilkenny, Co\&.Kilkenny');
.br
 std::shared_ptr<OSTM> boi_ptr = new \fBBOI\fP(200, 500, 'Joe', 'Blog', 'High street, Kilkenny, Co\&.Kilkenny');
.br
 std::shared_ptr<OSTM> boa_ptr = new \fBBOA\fP(300, 500, 'Joe', 'Blog', 'High street, Kilkenny, Co\&.Kilkenny');
.br
 std::shared_ptr<OSTM> swplc_ptr = new \fBSWBPLC\fP(400, 500, 'Joe', 'Blog', 'High street, Kilkenny, Co\&.Kilkenny');
.br
 std::shared_ptr<OSTM> ulster_ptr = new \fBULSTER\fP(500, 500, 'Joe', 'Blog', 'High street, Kilkenny, Co\&.Kilkenny');
.br
 std::shared_ptr<OSTM> unbl_ptr = new \fBUNBL\fP(600, 500, 'Joe', 'Blog', 'High street, Kilkenny, Co\&.Kilkenny');
.br
.PP
Create objects type of \fBWAREHOUSE\fP\&. All object will have unique ID by default
.br
 std::shared_ptr<OSTM> w_dist = new \fBCARPHONE_WAREHOUSE()\fP;
.br
 std::shared_ptr<OSTM> c_shop = new \fBCARLOW_W()\fP;
.br
 std::shared_ptr<OSTM> k_shop = new \fBKILKENNY_W()\fP;
.br
 std::shared_ptr<OSTM> t_shop = new \fBTALLAGH_W()\fP;
.br
 std::shared_ptr<OSTM> d_shop = new \fBDUNDALK_W()\fP;
.br
 std::shared_ptr<OSTM> s_shop = new \fBSLIGO_W()\fP;
.br
.PP
Create vector of std::shared_ptr<OSTM> \fBBANK\fP pointers
.br
 vector_number is 100 at the moment
.br
 for(int i=0;i<vector_number;++i)
.PP
Create vector of std::shared_ptr<OSTM> \fBWAREHOUSE\fP pointers
.br
 vector_number is 100 at the moment
.br
 for(int i=0;i<vector_number;++i)
.PP
Display \fBWAREHOUSE\fP objects before transaction
.br
 w_dist->toString();
.br
 c_shop->toString();
.br
 k_shop->toString();
.br
 t_shop->toString();
.br
 d_shop->toString();
.br
 s_shop->toString();
.br
.PP
Display \fBBANK\fP objects before transaction
.br
 aib_ptr->toString();
.br
 boi_ptr->toString();
.br
 boa_ptr->toString();
.br
 swplc_ptr->toString();
.br
 ulster_ptr->toString();
.br
 unbl_ptr->toString();
.br
.PP
\fBParameters:\fP
.RS 4
\fItransferAmount\fP in the transaction, control the value in the transaction between objetcs
.br
\fIthreadArraySize\fP control number of threads 
.br
 The logic in the IF ELSE statement distribute the threads between three different thread creating option\&.
.br
 If the threadArraySize is divisible with three, the threads will be distributed between function\&.
.br
 However, you can creates any number of threads, but to follow the correct output should increase the IF ELSE statement to distribute the threads in equal number\&.
.RE
.PP
Creating threads^n -> threadArraySize
.br
 for (int i = 0; i < threadArraySize; ++i)
.br
.PP
TEST 1 : Nested transaction Test
.br
 thArray[i] = std::thread(\fInesting\fP, aib_ptr, boi_ptr, std::ref(tm), transferAmount);
.PP
TEST 2 :Three different type of function call where the objects are participating in multiple type of transactions
.br
 thArray[i] = std::thread(\fItwo_account_transfer\fP, aib_ptr, boi_ptr, std::ref(tm), transferAmount);
.br
 thArray[i] = std::thread(\fIsix_account_transfer\fP, boi_ptr, boa_ptr, swplc_ptr, ulster_ptr, aib_ptr, unbl_ptr, std::ref(tm), transferAmount)
.br
 thArray[i] = std::thread(\fIcomplex_transfer\fP, aib_ptr, boi_ptr, std::ref(_customer_vec), std::ref(tm), transferAmount);
.PP
TEST 3 : Testing \fBWAREHOUSE\fP type pointers within transactions
.br
 thArray[i] = std::thread(\fIphone_transfer\fP, c_shop, w_dist, std::ref(tm), transferAmount);
.PP
TEST 4 : Testing \fBWAREHOUSE\fP type pointers within nested transactions
.br
 thArray[i] = std::thread(\fInested_warehouse_transfer\fP, c_shop, d_shop, k_shop, w_dist, std::ref(tm), transferAmount);
.PP
TEST 5 : Testing \fBWAREHOUSE\fP type pointers within mixed and nested transactions
.br
 thArray[i] = std::thread(\fIwarehouse_transfer\fP, c_shop, w_dist, std::ref(tm), transferAmount);
.br
 thArray[i] = std::thread(\fInested_warehouse_transfer\fP, c_shop, d_shop, k_shop, w_dist, std::ref(tm), transferAmount);
.br
 thArray[i] = std::thread(\fIcomplex_warehouse_transfer\fP, d_shop, c_shop, std::ref(_warehouse_vec), w_dist, std::ref(tm), transferAmount);
.br
.PP
Display objects after all transactions are finished
.br
 Uncomment the required corresponding TEST to display results
.PP
Extra tx to call and display ROLLBACK value
.br
 std::shared_ptr<TX> tx = tm\&._get_tx();
.br
.PP
Display the number of ROLLBACK by all the threads 
.br
 std::cout << 'Rollback counter is : ' << tx->getTest_counter() << std::endl;
.PP
Display object from vector
.PP
Clean up Transaction Manager from all main process associated transactions
.br
 tm\&._TX_EXIT();
.PP
Display all Transactions associated with the main process\&. It should be empty after _TX_EXIT() function call!!!
.br
 tm\&.print_all();
.PP
Definition at line 649 of file main\&.cpp\&.
.PP
References TM::_get_tx(), _nesting_(), TM::_TX_EXIT(), TM::Instance(), TM::print_all(), and vector_number\&.
.PP
.nf
649                {
654     TM& tm = TM::Instance();
655 
661 
662     std::vector<std::shared_ptr < OSTM>>_customer_vec; //(vector_number);
663     std::vector<std::shared_ptr < OSTM>>_warehouse_vec; //(vector_number);
664 
674     std::shared_ptr<OSTM> aib_ptr(new AIB(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
675     std::shared_ptr<OSTM> boi_ptr(new BOI(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
676     std::shared_ptr<OSTM> boa_ptr(new BOA(300, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
677     std::shared_ptr<OSTM> swplc_ptr(new SWBPLC(400, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
678     std::shared_ptr<OSTM> ulster_ptr(new ULSTER(500, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
679     std::shared_ptr<OSTM> unbl_ptr(new UNBL(600, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
680 
690 
691     std::shared_ptr<OSTM> w_dist(new CARPHONE_WAREHOUSE());
692     std::shared_ptr<OSTM> c_shop(new CARLOW_W());
693     std::shared_ptr<OSTM> k_shop(new KILKENNY_W());
694     std::shared_ptr<OSTM> t_shop(new TALLAGH_W());
695     std::shared_ptr<OSTM> d_shop(new DUNDALK_W());
696     std::shared_ptr<OSTM> s_shop(new SLIGO_W());
697 
703     for (int i = 0; i < vector_number; ++i) {
704         if (i % 5 == 0) {
705             std::shared_ptr<OSTM> sharedptr(new CARLOW_W());
706             _warehouse_vec\&.push_back(std::move(sharedptr));
707         } else if (i % 4 == 0) {
708             std::shared_ptr<OSTM> sharedptr(new KILKENNY_W());
709             _warehouse_vec\&.push_back(std::move(sharedptr));
710         } else if (i % 3 == 0) {
711             std::shared_ptr<OSTM> sharedptr(new TALLAGH_W());
712             _warehouse_vec\&.push_back(std::move(sharedptr));
713         } else if (i % 2 == 0) {
714             std::shared_ptr<OSTM> sharedptr(new DUNDALK_W());
715             _warehouse_vec\&.push_back(std::move(sharedptr));
716         } else if (i % 1 == 0) {
717             std::shared_ptr<OSTM> sharedptr(new SLIGO_W());
718             _warehouse_vec\&.push_back(std::move(sharedptr));
719         }
720     }
721 
727     for (int i = 0; i < vector_number; ++i) {
728         if (i % 6 == 0) {
729             std::shared_ptr<OSTM> sharedptr(new AIB(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
730             _customer_vec\&.push_back(std::move(sharedptr));
731         } else if (i % 5 == 0) {
732             std::shared_ptr<OSTM> sharedptr(new BOI(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
733             _customer_vec\&.push_back(std::move(sharedptr));
734         } else if (i % 4 == 0) {
735             std::shared_ptr<OSTM> sharedptr(new BOA(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
736             _customer_vec\&.push_back(std::move(sharedptr));
737         } else if (i % 3 == 0) {
738             std::shared_ptr<OSTM> sharedptr(new SWBPLC(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
739             _customer_vec\&.push_back(std::move(sharedptr));
740         } else if (i % 2 == 0) {
741             std::shared_ptr<OSTM> sharedptr(new ULSTER(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
742             _customer_vec\&.push_back(std::move(sharedptr));
743         } else if (i % 1 == 0) {
744             std::shared_ptr<OSTM> sharedptr(new UNBL(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
745             _customer_vec\&.push_back(std::move(sharedptr));
746         }
747     }
748 
758     //    w_dist->toString();
759     //    c_shop->toString();
760     //    k_shop->toString();
761     //    t_shop->toString();
762     //    d_shop->toString();
763     //    s_shop->toString();
764 
774 
775     /*
776      * TEST 1 : object requirements
777      */
778     aib_ptr->toString();
779     boi_ptr->toString();
780 
781     /*
782      * TEST 2 : object requirements 
783      */
784     //    aib_ptr->toString();
785     //    boi_ptr->toString();
786     //    boa_ptr->toString();
787     //    swplc_ptr->toString();
788     //    ulster_ptr->toString();
789     //    unbl_ptr->toString();
790     //    for(int i=0; i<vector_number; ++i){
791     //        _customer_vec[i]->toString();
792     //    }
793 
794     /*
795      * TEST 3 : object requirements
796      */
797     //    w_dist->toString();
798     //    c_shop->toString();
799     //    k_shop->toString();
800     //    t_shop->toString();
801 
802     /*
803      * TEST 4 : objects requirements
804      */
805     //        w_dist->toString();
806     //        c_shop->toString();
807     //        k_shop->toString();
808     //        t_shop->toString();
809     //        d_shop->toString();
810     //        s_shop->toString();
811 
812 
813     /*
814      * TEST 5 : objects requirements
815      */
816     //        w_dist->toString();
817     //        c_shop->toString();
818     //        k_shop->toString();
819     //        t_shop->toString();
820     //        d_shop->toString();
821     //        s_shop->toString();
822 
823     //        for(auto&& elem: _warehouse_vec){
824     //            elem->toString(); // virtual dispatch
825     //            
826     //        }
827 
828 
829 
833     int transferAmount = 1;
840     int threadArraySize = 99;
841     std::thread thArray[threadArraySize];
842 
847     for (int i = 0; i < threadArraySize; ++i) {
848 
853         if (i % 3 == 0)
854             thArray[i] = std::thread(_nesting_, aib_ptr, boi_ptr, std::ref(tm), transferAmount);
855         else if (i % 2 == 0)
856             thArray[i] = std::thread(_nesting_, aib_ptr, boi_ptr, std::ref(tm), transferAmount);
857         else if (i % 1 == 0)
858             thArray[i] = std::thread(_nesting_, aib_ptr, boi_ptr, std::ref(tm), transferAmount);
859 
866         //    if (i % 3 == 0) 
867         //        thArray[i] = std::thread(_two_account_transfer_, aib_ptr, boi_ptr, std::ref(tm), transferAmount);
868         //    else if (i % 2 == 0)
869         //        thArray[i] = std::thread(_six_account_transfer_, boi_ptr, boa_ptr, swplc_ptr, ulster_ptr, aib_ptr, unbl_ptr, std::ref(tm), transferAmount);
870         //    else if (i % 1 == 0)
871         //        thArray[i] = std::thread(_complex_transfer_, aib_ptr, boi_ptr, std::ref(_customer_vec), std::ref(tm), transferAmount);
872 
873 
878         //        if (i % 3 == 0)
879         //            thArray[i] = std::thread(_warehouse_transfer_, c_shop, w_dist, std::ref(tm), transferAmount);
880         //        else if (i % 2 == 0)
881         //            thArray[i] = std::thread(_warehouse_transfer_, k_shop, w_dist, std::ref(tm), transferAmount);
882         //        else if (i % 1 == 0)
883         //            thArray[i] = std::thread(_warehouse_transfer_, t_shop, w_dist, std::ref(tm), transferAmount);
884 
889         //        if (i % 3 == 0)
890         //            thArray[i] = std::thread(_nested_warehouse_transfer_, c_shop, d_shop, k_shop, w_dist, std::ref(tm), transferAmount);
891         //        else if (i % 2 == 0)
892         //            thArray[i] = std::thread(_nested_warehouse_transfer_, k_shop, s_shop, t_shop, w_dist, std::ref(tm), transferAmount);
893         //        else if (i % 1 == 0)
894         //            thArray[i] = std::thread(_nested_warehouse_transfer_, t_shop, c_shop, s_shop, w_dist, std::ref(tm), transferAmount);
895 
903 
904         //        if (i % 3 == 0)
905         //            thArray[i] = std::thread(_warehouse_transfer_, c_shop, w_dist, std::ref(tm), transferAmount);
906         //        else if (i % 2 == 0)
907         //            thArray[i] = std::thread(_nested_warehouse_transfer_, k_shop, s_shop, t_shop, w_dist, std::ref(tm), transferAmount);
908         //        else if (i % 1 == 0)
909         //            thArray[i] = std::thread(_complex_warehouse_transfer_, d_shop, s_shop, c_shop, std::ref(_warehouse_vec), w_dist, std::ref(tm), transferAmount);
910 
911 
912     }
913     /*
914      * Join threads^n -> threadArraySize<br>
915      * thArray[i]\&.join();
916      */
917     for (int i = 0; i < threadArraySize; ++i) {
918         thArray[i]\&.join();
919     }
920 
921 
922     std::cout << "\nMain process print " << std::endl;
927 
928     /*
929      * TEST 1 : object requirements
930      */
931     aib_ptr->toString();
932     boi_ptr->toString();
933 
934     /*
935      * TEST 2 : object requirements 
936      */
937     //    aib_ptr->toString();
938     //    boi_ptr->toString();
939     //    boa_ptr->toString();
940     //    swplc_ptr->toString();
941     //    ulster_ptr->toString();
942     //    unbl_ptr->toString();
943     //    for(int i=0; i<vector_number; ++i){
944     //        _customer_vec[i]->toString();
945     //    }
946 
947     /*
948      * TEST 3 : object requirements
949      */
950     //            w_dist->toString();
951     //            c_shop->toString();
952     //            k_shop->toString();
953     //            t_shop->toString();
954 
955     /*
956      * TEST 4 : objects requirements
957      */
958     //        w_dist->toString();
959     //        c_shop->toString();
960     //        k_shop->toString();
961     //        t_shop->toString();
962     //        d_shop->toString();
963     //        s_shop->toString();
964 
965     /*
966      * TEST 5 : objects requirements
967      */
968     //        w_dist->toString();
969     //        c_shop->toString();
970     //        k_shop->toString();
971     //        t_shop->toString();
972     //        d_shop->toString();
973     //        s_shop->toString();
974 
975     //        for(auto&& elem: _warehouse_vec){
976     //            elem->toString(); // virtual dispatch
977     //            
978     //        }
979 
980     /* TEST 5 FINISH */
981 
982 
983     std::cout << "\nMAIN PROCESS EXIT !!!! " << std::endl;
988     std::shared_ptr<TX> tx = tm\&._get_tx();
989 
994     std::cout << "Rollback counter is : " << tx->getTest_counter() << std::endl;
998     //    std::cout << "[vector_number]" << std::endl;
999     //    for (int i = 0; i < vector_number; ++i) {
1000     //        //_customer_vec[i]->toString();
1001     //        auto&& os = _customer_vec\&.at(i);
1002     //        os->toString();
1003     //    }
1004     //    std::cout << "[_warehouse_vec]" << std::endl;
1005     //    for(auto&& elem: _warehouse_vec){
1006     //        elem->toString(); // virtual dispatch
1007     //        
1008     //    }
1009     //_customer_vec[10]->toString();
1010 
1015     tm\&._TX_EXIT();
1016     std::cout << "\nPRINT ALL FROM TM !!!! SHOULD BE EMPTY AFTER _TX_EXIT() !!" << std::endl;
1021     tm\&.print_all();
1022 
1023     return 0;
1024 }
.fi
.SH "Variable Documentation"
.PP 
.SS "int vector_number = 600\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIvector_number\fP control the size of the vector to store std::shared_ptr<OSTM> pointer 
.RE
.PP

.PP
Definition at line 43 of file main\&.cpp\&.
.PP
Referenced by main()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for C++ Software transactional Memory from the source code\&.
