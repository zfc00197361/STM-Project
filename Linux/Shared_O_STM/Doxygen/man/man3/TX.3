.TH "TX" 3 "Sat Feb 24 2018" "Version v0.1" "O_STM" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TX \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <TX\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBTX\fP (std::thread::id id)"
.br
.RI "\fIConstructor\&. \fP"
.ti -1c
.RI "\fB~TX\fP ()"
.br
.RI "\fIDe-constructor\&. \fP"
.ti -1c
.RI "\fBTX\fP (const \fBTX\fP &orig)"
.br
.RI "\fIDefault copy constructor\&. \fP"
.ti -1c
.RI "void \fBostm_exit\fP ()"
.br
.RI "\fIDelete all map entries associated with the main process\&. \fP"
.ti -1c
.RI "void \fB_register\fP (std::shared_ptr< \fBOSTM\fP > object)"
.br
.RI "\fIRegister \fBOSTM\fP pointer into STM library\&. \fP"
.ti -1c
.RI "std::shared_ptr< \fBOSTM\fP > \fBload\fP (std::shared_ptr< \fBOSTM\fP > object)"
.br
.RI "\fIload std::shared_ptr<OSTM>, returning an std::shared_ptr<OSTM> copy of the original pointer, to work with during transaction life time \fP"
.ti -1c
.RI "void \fBstore\fP (std::shared_ptr< \fBOSTM\fP > object)"
.br
.RI "\fIStore transactional changes\&. \fP"
.ti -1c
.RI "bool \fBcommit\fP ()"
.br
.RI "\fICommit transactional changes\&. \fP"
.ti -1c
.RI "void \fB_increase_tx_nesting\fP ()"
.br
.RI "\fIAdd \fBTX\fP nesting level by one\&. \fP"
.ti -1c
.RI "void \fB_decrease_tx_nesting\fP ()"
.br
.RI "\fIRemove \fBTX\fP nesting level by one\&. \fP"
.ti -1c
.RI "int \fBgetTest_counter\fP ()"
.br
.RI "\fIgetTest_counter TESTING ONLY!!! returning the value of the test_counter stored, number of rollbacks \fP"
.ti -1c
.RI "void \fB_print_all_tx\fP ()"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static int \fBtest_counter\fP = 0"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBTM\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 24 of file TX\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "TX::TX (std::thread::id id)"

.PP
Constructor\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransaction_Number\fP int, to store associated thread 
.br
\fI_tx_nesting_level\fP int, to store and indicate nesting level of transactions within transaction 
.RE
.PP

.PP
Definition at line 31 of file TX\&.cpp\&.
.PP
.nf
31                      {
32     this->transaction_Number = id;
33     this->_tx_nesting_level = 0;
34 }
.fi
.SS "TX::~TX ()"

.PP
De-constructor\&. 
.PP
Definition at line 38 of file TX\&.cpp\&.
.PP
.nf
38         {
39    
40 }
.fi
.SS "TX::TX (const \fBTX\fP & orig)"

.PP
Default copy constructor\&. 
.PP
Definition at line 44 of file TX\&.cpp\&.
.PP
.nf
44                      {
45 
46 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void TX::_decrease_tx_nesting ()"

.PP
Remove \fBTX\fP nesting level by one\&. _decrease_tx_nesting decrease the value stored in _tx_nesting_level by one, when outer transactions commiting
.PP
\fBParameters:\fP
.RS 4
\fI_tx_nesting_level\fP int 
.RE
.PP

.PP
Definition at line 316 of file TX\&.cpp\&.
.PP
Referenced by commit()\&.
.PP
.nf
316                               {
317    // std::cout << "[this->_tx_nesting_level] = " << this->_tx_nesting_level << std::endl;
318     this->_tx_nesting_level -= 1;
319 ;
320 }
.fi
.SS "void TX::_increase_tx_nesting ()"

.PP
Add \fBTX\fP nesting level by one\&. _increase_tx_nesting increase the value stored in _tx_nesting_level by one, indicate that the transaction nested
.PP
\fBParameters:\fP
.RS 4
\fI_tx_nesting_level\fP int 
.RE
.PP

.PP
Definition at line 307 of file TX\&.cpp\&.
.PP
.nf
307                               {
308       
309     this->_tx_nesting_level += 1;
310     // std::cout << "[this->_tx_nesting_level] = " << this->_tx_nesting_level << std::endl;
311 }
.fi
.SS "void TX::_print_all_tx ()"
ONLY FOR TESTING CHECK THE MAP AFTER THREAD EXIT AND ALL SHOULD BE DELETED!!!!!!! 
.PP
Definition at line 346 of file TX\&.cpp\&.
.PP
.nf
346                        {
347 
348     std::cout << "[PRINTALLTHREAD]" << std::endl;
349     std::map< int, std::shared_ptr<OSTM> >::iterator it;
350     /*
351      * All registered thread id in the TX global 
352      */
353      pid_t ppid = getppid();
354     std::map<pid_t, std::map< int, int >>::iterator process_map_collection_Iterator = TX::process_map_collection\&.find(ppid);
355     if (process_map_collection_Iterator != TX::process_map_collection\&.end()) {
356 
357         for (auto current = process_map_collection_Iterator->second\&.begin(); current != process_map_collection_Iterator->second\&.end(); ++current) {
358             it = working_Map_collection\&.find(current->first);
359             if(it != working_Map_collection\&.end()){
360                 std::cout << "[Unique number ] : " <<it->second->Get_Unique_ID() << std::endl;
361             }
362 
363             
364         }
365      
366     }
367 }
.fi
.SS "void TX::_register (std::shared_ptr< \fBOSTM\fP > object)"

.PP
Register \fBOSTM\fP pointer into STM library\&. register void, receives an std::shared_ptr<OSTM> that point to the original memory space to protect from reca conditions
.PP
\fBParameters:\fP
.RS 4
\fIworking_Map_collection\fP std::map, store all the std::shared_ptr<OSTM> pointer in the transaction 
.br
\fImain_Process_Map_collection\fP std::map, store all std::shared_ptr<OSTM> from all transaction, used to lock and compare the objects 
.br
\fIprocess_map_collection\fP std::map, store all std::shared_ptr<OSTM> unique ID from all transaction, used to delete all pointers used by the main process, from all transaction before the program exit\&. 
.br
\fIstd::lock_guard\fP use register_Lock(mutex) shared lock between all transaction 
.br
\fIppid\fP int, store main process number 
.RE
.PP

.PP
Definition at line 104 of file TX\&.cpp\&.
.PP
.nf
104                                              {
105     /*
106      * MUST USE SHARED LOCK TO PROTECT SHARED GLOBAL MAP/COLLECTION 
107      */
108     std::lock_guard<std::mutex> guard(TX::register_Lock);
109     
110     /*
111      * Check for null pointer !
112      * Null pointer can cause segmentation fault!!!
113      */
114     if(object == nullptr){
115         throw std::runtime_error(std::string("[RUNTIME ERROR : NULL POINTER IN REGISTER FUNCTION]") );
116     }
117     
118     pid_t ppid = getppid();
119     std::map<pid_t, std::map< int, int >>::iterator process_map_collection_Iterator = TX::process_map_collection\&.find(ppid);
120     if (process_map_collection_Iterator == TX::process_map_collection\&.end()) {
121         /*
122          * Register main process/application to the global map
123          */
124         std::map< int, int >map =  get_thread_Map();
125         TX::process_map_collection\&.insert({ppid, map});
126         /*
127          * Get the map if registered first time
128          */
129         process_map_collection_Iterator = TX::process_map_collection\&.find(ppid);
130     }
131     std::map<int, std::shared_ptr<OSTM>>::iterator main_Process_Map_collection_Iterator = TX::main_Process_Map_collection\&.find(object->Get_Unique_ID());
132     if (main_Process_Map_collection_Iterator == TX::main_Process_Map_collection\&.end()) {
133         /*
134          * Insert to the GLOBAL MAP 
135          */
136         TX::main_Process_Map_collection\&.insert({object->Get_Unique_ID(), object});
137         /*
138          * Insert to the GLOBAL MAP as a helper to clean up at end of main process 
139          */
140         process_map_collection_Iterator->second\&.insert({object->Get_Unique_ID(), 1});
141     } 
142 
143 
144     std::map< int, std::shared_ptr<OSTM> >::iterator working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.find(object->Get_Unique_ID());
145     if (working_Map_collection_Object_Shared_Pointer_Iterator == working_Map_collection\&.end()) {
146 
147         working_Map_collection\&.insert({object->Get_Unique_ID(), object->getBaseCopy(object)});
148     }
149 
150 }
.fi
.SS "bool TX::commit ()"

.PP
Commit transactional changes\&. commit bool, returns boolean value TRUE/FALSE depends on the action taken within the function
.PP
\fBParameters:\fP
.RS 4
\fIworking_Map_collection\fP std::map, store all the std::shared_ptr<OSTM> pointer in the transaction 
.br
\fImain_Process_Map_collection\fP std::map, store all std::shared_ptr<OSTM> from all transaction, used to lock and compare the objects 
.br
\fIcan_Commit\fP bool, helps to make decision that the transaction can commit or rollback 
.RE
.PP

.PP
Definition at line 202 of file TX\&.cpp\&.
.PP
References _decrease_tx_nesting(), and test_counter\&.
.PP
.nf
202                 {
203 
204     bool can_Commit = true;
205  
206     /*
207      * Dealing with nested transactions first 
208      */
209     if (this->_tx_nesting_level > 0) {
210         _decrease_tx_nesting();
211         return true;
212     } 
213     
214     std::map< int, std::shared_ptr<OSTM> >::iterator working_Map_collection_Object_Shared_Pointer_Iterator;
215 
216     std::map<int, std::shared_ptr<OSTM>>::iterator main_Process_Map_collection_Iterator;
217     for (working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.begin(); working_Map_collection_Object_Shared_Pointer_Iterator != working_Map_collection\&.end(); working_Map_collection_Object_Shared_Pointer_Iterator++) {
218 
219             main_Process_Map_collection_Iterator = TX::main_Process_Map_collection\&.find(working_Map_collection_Object_Shared_Pointer_Iterator->second->Get_Unique_ID());
220             /*
221              * Throws runtime error if object can not find
222              */
223             if(main_Process_Map_collection_Iterator == TX::main_Process_Map_collection\&.end())
224             {
225                 throw std::runtime_error(std::string("[RUNTIME ERROR : CAN'T FIND OBJECT COMMIT FUNCTION]"));
226             }
227 
228         /*
229          * Busy wait WHILE object locked by other thread
230          */
231         while(!(main_Process_Map_collection_Iterator->second)->is_Locked());
232 
233         if (main_Process_Map_collection_Iterator->second->Get_Version() > working_Map_collection_Object_Shared_Pointer_Iterator->second->Get_Version()) {
234 
235             working_Map_collection_Object_Shared_Pointer_Iterator->second->Set_Can_Commit(false);
236             can_Commit = false;
237             break;
238         } else {
239 
240             working_Map_collection_Object_Shared_Pointer_Iterator->second->Set_Can_Commit(true);
241         }
242     }
243     if (!can_Commit) {
244         TX::test_counter += 1;
245         for (working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.begin(); working_Map_collection_Object_Shared_Pointer_Iterator != working_Map_collection\&.end(); working_Map_collection_Object_Shared_Pointer_Iterator++) {
246           
247             main_Process_Map_collection_Iterator  = TX::main_Process_Map_collection\&.find(working_Map_collection_Object_Shared_Pointer_Iterator->second->Get_Unique_ID());
248             (working_Map_collection_Object_Shared_Pointer_Iterator->second)->copy(working_Map_collection_Object_Shared_Pointer_Iterator->second, main_Process_Map_collection_Iterator->second);
249 
250         }
251         
252         _release_object_lock();
253 
254         return false;
255     } else {
256         /*
257          * Commit changes
258          */
259         for (working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.begin(); working_Map_collection_Object_Shared_Pointer_Iterator != working_Map_collection\&.end(); working_Map_collection_Object_Shared_Pointer_Iterator++) {
260             
261                 main_Process_Map_collection_Iterator = TX::main_Process_Map_collection\&.find((working_Map_collection_Object_Shared_Pointer_Iterator->second)->Get_Unique_ID());
262                 if (main_Process_Map_collection_Iterator != TX::main_Process_Map_collection\&.end()) {
263 
264                     (main_Process_Map_collection_Iterator->second)->copy(main_Process_Map_collection_Iterator->second, working_Map_collection_Object_Shared_Pointer_Iterator->second);
265                     main_Process_Map_collection_Iterator->second->increase_VersionNumber();
266 
267 
268                 } else {
269                     throw std::runtime_error(std::string("[RUNTIME ERROR : CAN'T FIND OBJECT COMMIT FUNCTION]"));
270 
271                 }
272         }
273 
274 
275         _release_object_lock();
276         this->th_exit();
277         return true;
278     }
279 }//Commit finish
.fi
.SS "int TX::getTest_counter ()"

.PP
getTest_counter TESTING ONLY!!! returning the value of the test_counter stored, number of rollbacks 
.PP
Definition at line 324 of file TX\&.cpp\&.
.PP
References test_counter\&.
.PP
.nf
324                         {
325     return TX::test_counter;
326 }
.fi
.SS "std::shared_ptr< \fBOSTM\fP > TX::load (std::shared_ptr< \fBOSTM\fP > object)"

.PP
load std::shared_ptr<OSTM>, returning an std::shared_ptr<OSTM> copy of the original pointer, to work with during transaction life time Register \fBOSTM\fP pointer into STM library
.PP
\fBParameters:\fP
.RS 4
\fIworking_Map_collection\fP std::map, store all the std::shared_ptr<OSTM> pointer in the transaction 
.RE
.PP

.PP
Definition at line 155 of file TX\&.cpp\&.
.PP
.nf
155                                                        {
156 
157     std::map< int, std::shared_ptr<OSTM> >::iterator working_Map_collection_Object_Shared_Pointer_Iterator;
158     /*
159      * Check for null pointer !
160      * Null pointer can cause segmentation fault!!!
161      */
162     if(object == nullptr){
163         throw std::runtime_error(std::string("[RUNTIME ERROR : NULL POINTER IN LOAD FUNCTION]") );
164     }
165 
166         working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.find(object->Get_Unique_ID());
167 
168     if (working_Map_collection_Object_Shared_Pointer_Iterator != working_Map_collection\&.end()) {
169 
170         return working_Map_collection_Object_Shared_Pointer_Iterator->second->getBaseCopy(working_Map_collection_Object_Shared_Pointer_Iterator->second);
171         
172     } else { throw std::runtime_error(std::string("[RUNTIME ERROR : NO OBJECT FOUND LOAD FUNCTION]") );}
173 }
.fi
.SS "void TX::ostm_exit ()"

.PP
Delete all map entries associated with the main process\&. ostm_exit void, clear all elements from the shared global collections associated with the main process
.PP
\fBParameters:\fP
.RS 4
\fImain_Process_Map_collection\fP std::map, store all std::shared_ptr<OSTM> from all transaction shared between multiple processes 
.br
\fIprocess_map_collection\fP std::map, store all unique id from all transaction within main process DO NOT CALL THIS METHOD EXPLICITLY!!!!!! WILL DELETE ALL PROCESS ASSOCIATED ELEMENTS!!!! 
.RE
.PP

.PP
Definition at line 72 of file TX\&.cpp\&.
.PP
Referenced by TM::_TX_EXIT()\&.
.PP
.nf
72                    {
73     std::map<int, std::shared_ptr<OSTM>>::iterator main_Process_Map_collection_Iterator;
74      
75     pid_t ppid = getppid();
76     std::map<pid_t, std::map< int, int >>::iterator process_map_collection_Iterator = TX::process_map_collection\&.find(ppid);
77     if (process_map_collection_Iterator != TX::process_map_collection\&.end()) {
78 
79         for (auto current = process_map_collection_Iterator->second\&.begin(); current != process_map_collection_Iterator->second\&.end(); ++current) {
80             main_Process_Map_collection_Iterator = TX::main_Process_Map_collection\&.find(current->first);
81 
82             if (main_Process_Map_collection_Iterator != TX::main_Process_Map_collection\&.end()){
83                 /*
84                  * Delete element from shared main_Process_Map_collection by object unique key value, shared_ptr will destroy automatically
85                  */
86                 TX::main_Process_Map_collection\&.erase(main_Process_Map_collection_Iterator->first);      
87             }
88         }
89         /*
90          * Delete from Process_map_collection, Main process exits delete association with library
91          */
92         TX::process_map_collection\&.erase(process_map_collection_Iterator->first);
93     }
94 }
.fi
.SS "void TX::store (std::shared_ptr< \fBOSTM\fP > object)"

.PP
Store transactional changes\&. store void, receive an std::shared_ptr<OSTM> object to store the changes within the transaction, depends the user action
.PP
\fBParameters:\fP
.RS 4
\fIworking_Map_collection\fP std::map, store all the std::shared_ptr<OSTM> pointer in the transaction 
.RE
.PP

.PP
Definition at line 178 of file TX\&.cpp\&.
.PP
.nf
178                                          {
179     /*
180      * Check for null pointer !
181      * Null pointer can cause segmentation fault!!!
182      */
183     if(object == nullptr){
184         throw std::runtime_error(std::string("[RUNTIME ERROR : NULL POINTER IN STORE FUNCTION]") );
185     }
186     
187     std::map< int, std::shared_ptr<OSTM> >::iterator working_Map_collection_Object_Shared_Pointer_Iterator;
188 
189     working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.find(object->Get_Unique_ID());
190     if (working_Map_collection_Object_Shared_Pointer_Iterator != working_Map_collection\&.end()) {
191 
192         working_Map_collection_Object_Shared_Pointer_Iterator->second = object;
193 
194     } else { std::cout << "[ERROR STORE]" << std::endl; }
195 }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBTM\fP\fC [friend]\fP"
Only \fBTM\fP Transaction Manager can create instance of \fBTX\fP Transaction 
.PP
Definition at line 70 of file TX\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "int TX::test_counter = 0\fC [static]\fP"

.PP
\fBParameters:\fP
.RS 4
\fItest_counter\fP int ONLY FOR TESTING!!!
.br
\fIstatic\fP Global counter for rollback 
.RE
.PP

.PP
Definition at line 78 of file TX\&.h\&.
.PP
Referenced by commit(), and getTest_counter()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for O_STM from the source code\&.
