.TH "TM" 3 "Sun Mar 11 2018" "C++ Software transactional Memory" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TM \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <TM\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "std::shared_ptr< \fBTX\fP > const \fB_get_tx\fP ()"
.br
.RI "\fI@81 _get_tx std::shared_ptr<TX>, return an trtansaction Object as a shared_ptr, if \fBTX\fP not exists then create and register\&.# If the transaction Object exists then increasing the nesting level within the Transaction Object\&. \fP"
.ti -1c
.RI "void \fB_TX_EXIT\fP ()"
.br
.RI "\fI@108 _TX_EXIT void, when the thread calls the ostm_exit function in the transaction, and it will clear all elements from the shared global collection associated with the main process \fP"
.ti -1c
.RI "void \fBprint_all\fP ()"
.br
.RI "\fI@132 ONLY FOR TESTING print_all void function , print out all object key from txMAP collection associated with the main process\&. \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBTM\fP & \fBInstance\fP ()"
.br
.RI "\fI@31 Instance \fBTM\fP, Scott Meyer's Singleton creation, thread safe Transaction Manager instance creation\&. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "std::map< std::thread::id, int > \fBget_thread_Map\fP ()"
.br
.RI "\fI@148 get_thread_Map std::map, returning a map to store all unique ID from all objects from all transactions within the main processes \fP"
.ti -1c
.RI "\fBTM\fP & \fBoperator=\fP (const \fBTM\fP &)=delete"
.br
.RI "\fI\fBTM\fP copy operator, prevent from copying the Transaction Manager\&. \fP"
.ti -1c
.RI "void \fBregisterTX\fP ()"
.br
.RI "\fI@45 registerTX void function, register a new \fBTX\fP Transaction object into ythe txMap/Transaction Map to manage all the transactions within the shared library\&. \fBTM\fP Transaction managger checking the Process ID existence in the process map collection, If not in the map then register\&. \fP"
.ti -1c
.RI "\fBTM\fP ()=default"
.br
.ti -1c
.RI "\fBTM\fP (const \fBTM\fP &)=delete"
.br
.RI "\fI\fBTM\fP copy constructor, prevent from copying the Transaction Manager\&. \fP"
.ti -1c
.RI "\fB~TM\fP ()=default"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::mutex \fBget_Lock\fP"
.br
.ti -1c
.RI "std::mutex \fBregister_Lock\fP"
.br
.ti -1c
.RI "std::map< std::thread::id, std::shared_ptr< \fBTX\fP > > \fBtxMap\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static pid_t \fB_tm_id\fP"
.br
.ti -1c
.RI "static std::map< pid_t, std::map< std::thread::id, int > > \fBprocess_map_collection\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 57 of file TM\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "TM::TM ()\fC [private]\fP, \fC [default]\fP"

.SS "TM::~TM ()\fC [private]\fP, \fC [default]\fP"

.SS "TM::TM (const \fBTM\fP &)\fC [private]\fP, \fC [delete]\fP"

.PP
\fBTM\fP copy constructor, prevent from copying the Transaction Manager\&. 
.SH "Member Function Documentation"
.PP 
.SS "std::shared_ptr< \fBTX\fP > const TM::_get_tx ()"

.PP
@81 _get_tx std::shared_ptr<TX>, return an trtansaction Object as a shared_ptr, if \fBTX\fP not exists then create and register\&.# If the transaction Object exists then increasing the nesting level within the Transaction Object\&. _get_tx std::shared_ptr<TX>, returning a shared pointer transaction object @85 guard std::lock_guard, locks the get_Lock mutex, unlock automatically when goes out of the scope
.PP
@85 get_Lock std::mutex, used by the lock_guard to protect txMap from race conditions
.PP
@87 txMap try to find the \fBTX\fP Transaction object by it's actual thread ID if registred in the txMap
.PP
@89 Check if iterator pointing to the end of the txMap then insert
.PP
@92 If cannot find then call the register function to register the thread with a transaction
.PP
@94 If it's registered first time then we need to find it after registration
.PP
@98 If transaction already registered, it means the thread participating in nested transactions, and increase the nesting
.PP
@101 Returning back the transaction (\fBTX\fP) object to the thread 
.PP
Definition at line 81 of file TM\&.cpp\&.
.PP
References get_Lock, registerTX(), and txMap\&.
.PP
.nf
82 {
85     std::lock_guard<std::mutex> guard(get_Lock);
87     std::map<std::thread::id, std::shared_ptr<TX>>::iterator it = txMap\&.find(std::this_thread::get_id());
89     if(it == txMap\&.end())
90     {
92        registerTX();
94        it = txMap\&.find(std::this_thread::get_id());
95        
96     } else {
98         it->second->_increase_tx_nesting();
99     }
101     return it->second;
102 
103 }
.fi
.SS "void TM::_TX_EXIT ()"

.PP
@108 _TX_EXIT void, when the thread calls the ostm_exit function in the transaction, and it will clear all elements from the shared global collection associated with the main process _TX_EXIT void function, the thread (\fBTX\fP object) calls the ostm_exit function from the transaction, and clear all elements from the shared global collection associated with the main process @110 Transaction manger create a local Transaction Object to access the \fBTX\fP class function without nesting any transaction
.PP
@112 getppid() return the actual main process thread id, I used it to associate the Transactionas with the main processes
.PP
@114 process_map_collection try to find the main process by it's ppid if registred in the library
.PP
@116 Check if iterator NOT pointing to the end of the process map then register
.PP
@118 Iterate through the process_map_collection to find all transaction associated with main process
.PP
@120 Delete all transaction associated with the actual main process
.PP
@123 When all transaction deleted, delete the main process from the Transacion Manager
.PP
@126 \fBTX\fP class delete all Global Object shared between the transaction\&. This function calls only when the main process exists to clear out memory 
.PP
Definition at line 108 of file TM\&.cpp\&.
.PP
References TX::ostm_exit(), process_map_collection, and txMap\&.
.PP
.nf
108                  {
110     TX tx(std::this_thread::get_id());
112     pid_t ppid = getppid();
114     std::map<pid_t, std::map< std::thread::id, int >>::iterator process_map_collection_Iterator = TM::process_map_collection\&.find(ppid);
116     if (process_map_collection_Iterator != TM::process_map_collection\&.end()) {
118         for (auto current = process_map_collection_Iterator->second\&.begin(); current != process_map_collection_Iterator->second\&.end(); ++current) {
120             txMap\&.erase(current->first);
121         }
123         TM::process_map_collection\&.erase(ppid);
124     }
126     tx\&.ostm_exit();
127 }
.fi
.SS "std::map< std::thread::id, int > TM::get_thread_Map ()\fC [private]\fP"

.PP
@148 get_thread_Map std::map, returning a map to store all unique ID from all objects from all transactions within the main processes @150 thread_Map std::map< int, int > create a map to store int key and int value
.PP
@152 return the map 
.PP
Definition at line 148 of file TM\&.cpp\&.
.PP
Referenced by registerTX()\&.
.PP
.nf
148                                               { 
150     std::map< std::thread::id, int > thread_Map;
152     return thread_Map;
153 }
.fi
.SS "\fBTM\fP & TM::Instance ()\fC [static]\fP"

.PP
@31 Instance \fBTM\fP, Scott Meyer's Singleton creation, thread safe Transaction Manager instance creation\&. Scott Meyer's Singleton creation, thread safe Transaction Manager instance creation\&. @33 _instance \fBTM\fP, static class reference to the instance of the Transaction Manager class
.PP
@35 _instance ppid, assigning the process id whoever created the Singleton instance
.PP
@37 return Singleton instance 
.PP
Definition at line 31 of file TM\&.cpp\&.
.PP
References _tm_id\&.
.PP
.nf
31                  {
33     static TM _instance;
35     _instance\&._tm_id = getpid();
37     return _instance;
38 }
.fi
.SS "\fBTM\fP& TM::operator= (const \fBTM\fP &)\fC [private]\fP, \fC [delete]\fP"

.PP
\fBTM\fP copy operator, prevent from copying the Transaction Manager\&. 
.SS "void TM::print_all ()"

.PP
@132 ONLY FOR TESTING print_all void function , print out all object key from txMAP collection associated with the main process\&. ONLY FOR TESTING! print_all void function, prints all object in the txMap @134 Locking the print function
.PP
@136 Iterate through the txMap to print out the thread id's
.PP
@138 Print key (thread number)
.PP
@140 Unlocking the print function 
.PP
Definition at line 132 of file TM\&.cpp\&.
.PP
References get_Lock, and txMap\&.
.PP
.nf
132                   {
134     get_Lock\&.lock();
136     for (auto current = txMap\&.begin(); current != txMap\&.end(); ++current) {
138         std::cout << "KEY : " << current->first << std::endl;
139     }
141     get_Lock\&.unlock();
142 }
.fi
.SS "void TM::registerTX ()\fC [private]\fP"

.PP
@45 registerTX void function, register a new \fBTX\fP Transaction object into ythe txMap/Transaction Map to manage all the transactions within the shared library\&. \fBTM\fP Transaction managger checking the Process ID existence in the process map collection, If not in the map then register\&. @49 guard std::lock_guard, locks the register_Lock mutex, unlock automatically when goes out of the scope
.PP
@49 register_Lock std::mutex, used by the lock_guard to protect shared map from race conditions
.PP
@51 getppid() return the actual main process thread id, I used it to associate the Transactionas with the main processes
.PP
@53 process_map_collection try to find the main process by it's ppid if registred in the library
.PP
@55 Check if iterator pointing to the end of the process map then register
.PP
@57 Require new map to insert to the process map as a value by the ppid key
.PP
@59 Register main process/application to the global map
.PP
@63 txMap std::map, collection to store all transaction created by the Transaction Manager
.PP
@65 Check if iterator pointing to the end of the txMap then insert
.PP
@67 Create a new Transaction Object as a shared pointer
.PP
@69 txMap insert the new transaction into the txMap by the threadID key
.PP
@71 Get the map if the transaction registered first time
.PP
@73 Insert to the GLOBAL MAP as a helper to clean up at end of main process\&. The value 1 is not used yet 
.PP
Definition at line 45 of file TM\&.cpp\&.
.PP
References get_thread_Map(), process_map_collection, register_Lock, and txMap\&.
.PP
Referenced by _get_tx()\&.
.PP
.nf
46 {
49     std::lock_guard<std::mutex> guard(register_Lock);
51     pid_t ppid = getppid();
53     std::map<pid_t, std::map< std::thread::id, int >>::iterator process_map_collection_Iterator = TM::process_map_collection\&.find(ppid);
55     if (process_map_collection_Iterator == TM::process_map_collection\&.end()) {
57         std::map< std::thread::id, int >map = get_thread_Map();
59         TM::process_map_collection\&.insert({ppid, map});
60 
61     }
63     std::map<std::thread::id, std::shared_ptr < TX>>::iterator it = txMap\&.find(std::this_thread::get_id());
65     if (it == txMap\&.end()) {
67         std::shared_ptr<TX> _transaction_object(new TX(std::this_thread::get_id()));
69         txMap\&.insert({std::this_thread::get_id(), _transaction_object});
71         process_map_collection_Iterator = TM::process_map_collection\&.find(ppid);
73         process_map_collection_Iterator->second\&.insert({std::this_thread::get_id(), 1});
74     }
75 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "pid_t TM::_tm_id\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 102 of file TM\&.h\&.
.PP
Referenced by Instance()\&.
.SS "std::mutex TM::get_Lock\fC [private]\fP"

.PP
Definition at line 98 of file TM\&.h\&.
.PP
Referenced by _get_tx(), and print_all()\&.
.SS "std::map< pid_t, std::map< std::thread::id, int > > TM::process_map_collection\fC [static]\fP, \fC [private]\fP"

.PP
Definition at line 82 of file TM\&.h\&.
.PP
Referenced by _TX_EXIT(), and registerTX()\&.
.SS "std::mutex TM::register_Lock\fC [private]\fP"

.PP
Definition at line 94 of file TM\&.h\&.
.PP
Referenced by registerTX()\&.
.SS "std::map<std::thread::id, std::shared_ptr<\fBTX\fP> > TM::txMap\fC [private]\fP"

.PP
Definition at line 78 of file TM\&.h\&.
.PP
Referenced by _get_tx(), _TX_EXIT(), print_all(), and registerTX()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for C++ Software transactional Memory from the source code\&.
