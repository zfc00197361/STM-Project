.TH "TX" 3 "Sun Mar 11 2018" "C++ Software transactional Memory" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TX \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <TX\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fB_decrease_tx_nesting\fP ()"
.br
.RI "\fI@279 _decrease_tx_nesting decrease the value stored in _tx_nesting_level by one, when outer transactions commit \fP"
.ti -1c
.RI "void \fB_increase_tx_nesting\fP ()"
.br
.RI "\fI@272 _increase_tx_nesting increase the value stored in _tx_nesting_level by one, indicate that the transaction was nested \fP"
.ti -1c
.RI "void \fB_print_all_tx\fP ()"
.br
.ti -1c
.RI "void \fB_register\fP (std::shared_ptr< \fBOSTM\fP > object)"
.br
.RI "\fIregister void, receives an std::shared_ptr<OSTM> that point to the original memory space to protect from reca conditions \fP"
.ti -1c
.RI "bool \fBcommit\fP ()"
.br
.RI "\fI@176 commit function, returns boolean value TRUE/FALSE depends on the action taken within the function\&. if commit happens return TRUE, otherwise return FALSE, indicate the transaction muist restart\&. \fP"
.ti -1c
.RI "int \fBgetTest_counter\fP ()"
.br
.RI "\fI@287 getTest_counter TESTING ONLY!!! returning the value of the test_counter stored, representing the number of rollbacks \fP"
.ti -1c
.RI "std::shared_ptr< \fBOSTM\fP > \fBload\fP (std::shared_ptr< \fBOSTM\fP > object)"
.br
.RI "\fI@137 load std::shared_ptr<OSTM>, returning an \fBOSTM\fP type shared pointer, that is copy of the original pointer stored in the working map, to work with during transaction life time \fP"
.ti -1c
.RI "void \fBostm_exit\fP ()"
.br
.RI "\fI@68 ostm_exit void, clear all elements from the shared global collections associated with the main process \fP"
.ti -1c
.RI "void \fBstore\fP (std::shared_ptr< \fBOSTM\fP > object)"
.br
.RI "\fI@157 store void, receive an \fBOSTM\fP type shared pointer object to store the changes with the transaction copy object \fP"
.ti -1c
.RI "\fBTX\fP (std::thread::id id)"
.br
.RI "\fI@36 Custom Constructor \fP"
.ti -1c
.RI "\fBTX\fP (const \fBTX\fP &orig)"
.br
.ti -1c
.RI "\fB~TX\fP ()"
.br
.RI "\fI@45 De-constructor \fP"
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static int \fBtest_counter\fP = 0"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "const std::thread::id \fB_get_tx_number\fP () const "
.br
.RI "\fI@294 _get_tx_number, returning the thread id that has assigned the given transaction \fP"
.ti -1c
.RI "void \fB_release_object_lock\fP ()"
.br
.RI "\fI@253 _release_object_lock void function, is get called from commit function, with the purpose to release the locks on all the objects participating in the transaction \fP"
.ti -1c
.RI "std::map< int, int > \fBget_thread_Map\fP ()"
.br
.RI "\fI@301 get_thread_Map, returning a map to store all unique ID from all objects from all transactions within the main process \fP"
.ti -1c
.RI "void \fBth_exit\fP ()"
.br
.RI "\fI@52 th_exit void, delete all std::shared_ptr<OSTM> elements from working_Map_collection, that store pointers to working objects \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "int \fB_tx_nesting_level\fP"
.br
.ti -1c
.RI "std::thread::id \fBtransaction_Number\fP"
.br
.ti -1c
.RI "std::map< int, std::shared_ptr< \fBOSTM\fP > > \fBworking_Map_collection\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static std::map< int, std::shared_ptr< \fBOSTM\fP > > \fBmain_Process_Map_collection\fP"
.br
.ti -1c
.RI "static std::map< pid_t, std::map< int, int > > \fBprocess_map_collection\fP"
.br
.ti -1c
.RI "static std::mutex \fBregister_Lock\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBTM\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 29 of file TX\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "TX::TX (std::thread::id id)"

.PP
@36 Custom Constructor 
.PP
\fBParameters:\fP
.RS 4
\fIid\fP std::thread::id, represent the transaction number when to the TransactionManager 
.RE
.PP
@38 Integer field <transaction_Number> indicates the transaction number to the Transaction manager
.PP
@40 Integer field <_tx_nesting_level> indicates the nesting level to the transaction itself 
.PP
Definition at line 36 of file TX\&.cpp\&.
.PP
References _tx_nesting_level, and transaction_Number\&.
.PP
.nf
36                      {
38     this->transaction_Number = id;
40     this->_tx_nesting_level = 0;
41 }
.fi
.SS "TX::~TX ()"

.PP
@45 De-constructor Delete the object\&. 
.PP
Definition at line 45 of file TX\&.cpp\&.
.PP
.nf
45         {
47 }
.fi
.SS "TX::TX (const \fBTX\fP & orig)"

.SH "Member Function Documentation"
.PP 
.SS "void TX::_decrease_tx_nesting ()"

.PP
@279 _decrease_tx_nesting decrease the value stored in _tx_nesting_level by one, when outer transactions commit @281 Decrease transaction nesting level 
.PP
Definition at line 279 of file TX\&.cpp\&.
.PP
References _tx_nesting_level\&.
.PP
Referenced by commit()\&.
.PP
.nf
279                               {
281     this->_tx_nesting_level -= 1;
282 ;
283 }
.fi
.SS "const std::thread::id TX::_get_tx_number () const\fC [private]\fP"

.PP
@294 _get_tx_number, returning the thread id that has assigned the given transaction _get_tx_number, returning the transaction uniqe identifier @296 Return the transaction nuber 
.PP
Definition at line 294 of file TX\&.cpp\&.
.PP
References transaction_Number\&.
.PP
.nf
294                                            {
296     return transaction_Number;
297 }
.fi
.SS "void TX::_increase_tx_nesting ()"

.PP
@272 _increase_tx_nesting increase the value stored in _tx_nesting_level by one, indicate that the transaction was nested @274 Increase transaction nesting level 
.PP
Definition at line 272 of file TX\&.cpp\&.
.PP
References _tx_nesting_level\&.
.PP
.nf
272                               {
274     this->_tx_nesting_level += 1;
275 }
.fi
.SS "void TX::_print_all_tx ()"
@311 _print_all_tx, only for testing! Prints all transaction associated with the main procees\&.! @313 initialise Iterator
.PP
@315 getppid() return the actual main process thread id, I used it to associate the Transactionas with the main processes
.PP
'317 initialize and assign Iterator to process_map_collection, by the main process id (ppid)
.PP
@319 If there is an entry associated with the process then print out all transactions\&.
.PP
@321 Iterate through process_map_collection
.PP
@323 Assign value to iterator
.PP
@325 If value found, then print it
.PP
@327 print out the transaction number 
.PP
Definition at line 311 of file TX\&.cpp\&.
.PP
References process_map_collection, and working_Map_collection\&.
.PP
.nf
311                        {
313     std::map< int, std::shared_ptr<OSTM> >::iterator it;
315     pid_t ppid = getppid();
317     std::map<pid_t, std::map< int, int >>::iterator process_map_collection_Iterator = TX::process_map_collection\&.find(ppid);
319     if (process_map_collection_Iterator != TX::process_map_collection\&.end()) {
321         for (auto current = process_map_collection_Iterator->second\&.begin(); current != process_map_collection_Iterator->second\&.end(); ++current) {
323             it = working_Map_collection\&.find(current->first);
325             if(it != working_Map_collection\&.end()){
327                 std::cout << "[Unique number ] : " <<it->second->Get_Unique_ID() << std::endl;
328             } 
329         }
330     }
331 }
.fi
.SS "void TX::_register (std::shared_ptr< \fBOSTM\fP > object)"

.PP
register void, receives an std::shared_ptr<OSTM> that point to the original memory space to protect from reca conditions 
.PP
\fBParameters:\fP
.RS 4
\fIobject\fP std::shared_ptr<OSTM>, is an original shared pointer point to the object memory space 
.RE
.PP
@98 register_Lock(mutex) shared lock between all transaction\&. MUST USE SHARED LOCK TO PROTECT SHARED GLOBAL MAP/COLLECTION
.PP
@100 RUNTIME ERROR\&. Check for null pointer ! Null pointer can cause segmentation fault!!!
.PP
@104 getppid() return the actual main process thread id, I used it to associate the Transactionas with the main processes
.PP
@106 Declare and initialize Iterator for process_map_collection, find main process
.PP
@108 If iterator cannot find main process, then register
.PP
@110 Create new empty map
.PP
@112 Register main process/application to the global map
.PP
@114 Get the map if registered first time
.PP
@117 Declare and initialize Iterator for main_Process_Map_collection, find by original object
.PP
@119 If object cannot find, then register
.PP
'121 Insert the origin object to the GLOBAL MAP shared between transactions
.PP
@123 Insert object ID to the GLOBAL MAP as a helper to clean up at end of main process, Second value (1) not specified yet
.PP
@126 Declare and initialize Iterator for working_Map_collection, find copy of the original object
.PP
@128 If copy of the object not found, then register
.PP
@130 Register transaction own copy of the original object 
.PP
Definition at line 96 of file TX\&.cpp\&.
.PP
References get_thread_Map(), main_Process_Map_collection, process_map_collection, register_Lock, and working_Map_collection\&.
.PP
.nf
96                                              {
98     std::lock_guard<std::mutex> guard(TX::register_Lock);
100     if(object == nullptr){
101         throw std::runtime_error(std::string("[RUNTIME ERROR : NULL POINTER IN REGISTER FUNCTION]") );
102     }
104     pid_t ppid = getppid();
106     std::map<pid_t, std::map< int, int >>::iterator process_map_collection_Iterator = TX::process_map_collection\&.find(ppid);
108     if (process_map_collection_Iterator == TX::process_map_collection\&.end()) {
110         std::map< int, int >map =  get_thread_Map();
112         TX::process_map_collection\&.insert({ppid, map});
114         process_map_collection_Iterator = TX::process_map_collection\&.find(ppid);
115     }
117     std::map<int, std::shared_ptr<OSTM>>::iterator main_Process_Map_collection_Iterator = TX::main_Process_Map_collection\&.find(object->Get_Unique_ID());
119     if (main_Process_Map_collection_Iterator == TX::main_Process_Map_collection\&.end()) {
121         TX::main_Process_Map_collection\&.insert({object->Get_Unique_ID(), object});
123         process_map_collection_Iterator->second\&.insert({object->Get_Unique_ID(), 1});
124     } 
126     std::map< int, std::shared_ptr<OSTM> >::iterator working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.find(object->Get_Unique_ID());
128     if (working_Map_collection_Object_Shared_Pointer_Iterator == working_Map_collection\&.end()) {
130         working_Map_collection\&.insert({object->Get_Unique_ID(), object->getBaseCopy(object)});
131     }
132 }
.fi
.SS "void TX::_release_object_lock ()\fC [private]\fP"

.PP
@253 _release_object_lock void function, is get called from commit function, with the purpose to release the locks on all the objects participating in the transaction _release_object_lock, Release the locks on all Shared global objects used by the transaction @255 Declare Iterator for working_Map_collection
.PP
@255 Declare Iterator for working_Map_collection
.PP
@260 Find Global shared original object by the transaction object unique ID
.PP
@262 If object found, then release lock
.PP
@264 Release object lock 
.PP
Definition at line 253 of file TX\&.cpp\&.
.PP
References main_Process_Map_collection, and working_Map_collection\&.
.PP
Referenced by commit()\&.
.PP
.nf
253                              {
255     std::map< int, std::shared_ptr<OSTM> >::iterator working_Map_collection_Object_Shared_Pointer_Iterator;
257     std::map<int, std::shared_ptr<OSTM>>::iterator main_Process_Map_collection_Iterator;
258     for (working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.begin(); working_Map_collection_Object_Shared_Pointer_Iterator != working_Map_collection\&.end(); working_Map_collection_Object_Shared_Pointer_Iterator++) {
260             main_Process_Map_collection_Iterator = TX::main_Process_Map_collection\&.find((working_Map_collection_Object_Shared_Pointer_Iterator->second)->Get_Unique_ID());
262             if (main_Process_Map_collection_Iterator != TX::main_Process_Map_collection\&.end()) {
264                 (main_Process_Map_collection_Iterator)->second->unlock_Mutex();
265             } 
266         }
267 }
.fi
.SS "bool TX::commit ()"

.PP
@176 commit function, returns boolean value TRUE/FALSE depends on the action taken within the function\&. if commit happens return TRUE, otherwise return FALSE, indicate the transaction muist restart\&. @179 Declare can_Commit boolean variable
.PP
@182 Dealing with nested transactions first\&. if nesting level bigger than ZERO do not commit yet
.PP
@183 Decrease nesting level 
.PP
\fBSee also:\fP
.RS 4
\fB_decrease_tx_nesting()\fP
.RE
.PP
@187 Declare and initialize Iterator for working_Map_collection
.PP
@189 Declare and initialize Iterator for main_Process_Map_collectio
.PP
@191 Iterate through the working_Map_collection, for all associated copy objetcs
.PP
@193 Find the Original object in the Shared global colection by the copy object unique ID
.PP
@195 RUNTIME ERROR\&. If no object found ! Null pointer can cause segmentation fault!!!
.PP
@200 Busy waiting, If the object locked by another transaction, then waith until it's get unlockec, then lock it
.PP
@203 Compare the original global object version number with the working object version number\&. If the version number not same, then it cannot coomit
.PP
@2005 Set object boolean value to FALSE, cannot commit
.PP
@207 Set canCommit false Indicate rollback must happen
.PP
@210 If version number are has same value set object boolean value to TRUE
.PP
@214 IF can_Commit boolean value setted for FALSE then rollback all copy object in the transaction to the Global object values
.PP
@217 iterate through all transaction copy objects one by one
.PP
@219 Find the Global shared object by the transaction copy object unique ID
.PP
@221 Copy all Global shared original objects changed values by another transaction to the transaction copy objetcs
.PP
@224 When the transaction finish to change copying all values from original objects to local copy, then release all Global shared objects\&. 
.PP
\fBSee also:\fP
.RS 4
\fB_release_object_lock()\fP
.RE
.PP
@226 Return FALSE to indicate the transaction must restart !
.PP
@229 Iterate through working_map_collection\&. If no conflict detected in early stage in the transaction, then commit all the local changes to shared Global objects
.PP
@231 Find the Global shared object by the transaction copy object unique ID
.PP
@233 If Global shared object found then commit changes
.PP
@235 Copy over local transaction object values to original Global object
.PP
@237 Increase the version number in the original pointer
.PP
@195 RUNTIME ERROR\&. If no object found ! Null pointer can cause segmentation fault!!!
.PP
@242 When the transaction finish with commit all changes, then release all Global shared objects\&. 
.PP
\fBSee also:\fP
.RS 4
\fB_release_object_lock()\fP
.RE
.PP
@244 Transaction object clean up all associated values, clean memory\&. 
.PP
\fBSee also:\fP
.RS 4
\fBth_exit()\fP
.RE
.PP
@246 Return TRUE, indicate the transaction has finished\&. 
.PP
Definition at line 177 of file TX\&.cpp\&.
.PP
References _decrease_tx_nesting(), _release_object_lock(), _tx_nesting_level, main_Process_Map_collection, th_exit(), and working_Map_collection\&.
.PP
.nf
177                 {
179     bool can_Commit = true;
181     if (this->_tx_nesting_level > 0) {
183         _decrease_tx_nesting();
184         return true;
185     } 
187     std::map< int, std::shared_ptr<OSTM> >::iterator working_Map_collection_Object_Shared_Pointer_Iterator;
189     std::map<int, std::shared_ptr<OSTM>>::iterator main_Process_Map_collection_Iterator;
191     for (working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.begin(); working_Map_collection_Object_Shared_Pointer_Iterator != working_Map_collection\&.end(); working_Map_collection_Object_Shared_Pointer_Iterator++) {
193             main_Process_Map_collection_Iterator = TX::main_Process_Map_collection\&.find(working_Map_collection_Object_Shared_Pointer_Iterator->second->Get_Unique_ID());
195             if(main_Process_Map_collection_Iterator == TX::main_Process_Map_collection\&.end())
196             {
197                 throw std::runtime_error(std::string("[RUNTIME ERROR : CAN'T FIND OBJECT COMMIT FUNCTION]"));
198             }
199 
201         while(!(main_Process_Map_collection_Iterator->second)->is_Locked());
203         if (main_Process_Map_collection_Iterator->second->Get_Version() > working_Map_collection_Object_Shared_Pointer_Iterator->second->Get_Version()) {
205             working_Map_collection_Object_Shared_Pointer_Iterator->second->Set_Can_Commit(false);
207             can_Commit = false;
208             break;
209         } else { 
211             working_Map_collection_Object_Shared_Pointer_Iterator->second->Set_Can_Commit(true);
212         }
213     }
215     if (!can_Commit) {
217         for (working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.begin(); working_Map_collection_Object_Shared_Pointer_Iterator != working_Map_collection\&.end(); working_Map_collection_Object_Shared_Pointer_Iterator++) {
219             main_Process_Map_collection_Iterator  = TX::main_Process_Map_collection\&.find(working_Map_collection_Object_Shared_Pointer_Iterator->second->Get_Unique_ID());
221             (working_Map_collection_Object_Shared_Pointer_Iterator->second)->copy(working_Map_collection_Object_Shared_Pointer_Iterator->second, main_Process_Map_collection_Iterator->second);
222         }
224         _release_object_lock();
226         return false;
227     } else {
229         for (working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.begin(); working_Map_collection_Object_Shared_Pointer_Iterator != working_Map_collection\&.end(); working_Map_collection_Object_Shared_Pointer_Iterator++) {
231                 main_Process_Map_collection_Iterator = TX::main_Process_Map_collection\&.find((working_Map_collection_Object_Shared_Pointer_Iterator->second)->Get_Unique_ID());
233                 if (main_Process_Map_collection_Iterator != TX::main_Process_Map_collection\&.end()) {
235                     (main_Process_Map_collection_Iterator->second)->copy(main_Process_Map_collection_Iterator->second, working_Map_collection_Object_Shared_Pointer_Iterator->second);
237                     main_Process_Map_collection_Iterator->second->increase_VersionNumber();
239                 } else { throw std::runtime_error(std::string("[RUNTIME ERROR : CAN'T FIND OBJECT COMMIT FUNCTION]")); }
240         }
242         _release_object_lock();
244         this->th_exit();
246         return true;
247     }
248 }//Commit finish
.fi
.SS "std::map< int, int > TX::get_thread_Map ()\fC [private]\fP"

.PP
@301 get_thread_Map, returning a map to store all unique ID from all objects from all transactions within the main process get_thread_Map, returning and map to insert to the process_map_collection as an inner value @303 initialize empty map hold int key and values
.PP
@305 Return the map 
.PP
Definition at line 301 of file TX\&.cpp\&.
.PP
Referenced by _register()\&.
.PP
.nf
301                                       {
303     std::map< int, int > thread_Map;
305     return thread_Map;
306 }
.fi
.SS "int TX::getTest_counter ()"

.PP
@287 getTest_counter TESTING ONLY!!! returning the value of the test_counter stored, representing the number of rollbacks @289 return class level value hold by test_counter variable 
.PP
Definition at line 287 of file TX\&.cpp\&.
.PP
References test_counter\&.
.PP
.nf
287                         {
289     return TX::test_counter;
290 }
.fi
.SS "std::shared_ptr< \fBOSTM\fP > TX::load (std::shared_ptr< \fBOSTM\fP > object)"

.PP
@137 load std::shared_ptr<OSTM>, returning an \fBOSTM\fP type shared pointer, that is copy of the original pointer stored in the working map, to work with during transaction life time 
.PP
\fBParameters:\fP
.RS 4
\fIobject\fP std::shared_ptr<OSTM>, used as a reference to find transaction copy object by the object unique ID 
.RE
.PP
@139 Declare and initialize Iterator for working_Map_collection
.PP
@141 RUNTIME ERROR\&. Check for null pointer ! Null pointer can cause segmentation fault!!!
.PP
@145 Find copy object in working_Map_collection by the object unique ID
.PP
@147 If object found, then return it
.PP
@149 Returning a copy of the working copy object
.PP
@151 If no object found, throw runtime error 
.PP
Definition at line 137 of file TX\&.cpp\&.
.PP
References working_Map_collection\&.
.PP
.nf
137                                                        {
139     std::map< int, std::shared_ptr<OSTM> >::iterator working_Map_collection_Object_Shared_Pointer_Iterator;
141     if(object == nullptr){
142         throw std::runtime_error(std::string("[RUNTIME ERROR : NULL POINTER IN LOAD FUNCTION]") );
143     }
145     working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.find(object->Get_Unique_ID());
147     if (working_Map_collection_Object_Shared_Pointer_Iterator != working_Map_collection\&.end()) {
149         return working_Map_collection_Object_Shared_Pointer_Iterator->second->getBaseCopy(working_Map_collection_Object_Shared_Pointer_Iterator->second);  
151     } else { throw std::runtime_error(std::string("[RUNTIME ERROR : NO OBJECT FOUND LOAD FUNCTION]") );}
152 }
.fi
.SS "void TX::ostm_exit ()"

.PP
@68 ostm_exit void, clear all elements from the shared global collections associated with the main process 
.PP
\fBParameters:\fP
.RS 4
\fImain_Process_Map_collection\fP std::map, store all std::shared_ptr<OSTM> from all transaction shared between multiple processes 
.br
\fIprocess_map_collection\fP std::map, store all unique id from all transaction within main process DO NOT CALL THIS METHOD EXPLICITLY!!!!!! WILL DELETE ALL PROCESS ASSOCIATED ELEMENTS!!!! 
.RE
.PP
@70 Declare Iterator main_Process_Map_collection_Iterator
.PP
@72 getppid() return the actual main process thread id, I used it to associate the Transactionas with the main processes
.PP
@74 process_map_collection try to find the main process by it's ppid if registred in the library
.PP
@76 Check if iterator NOT pointing to the end of the process_map_collection then remove all associated elements
.PP
@78 Iterate through the process_map_collection to find all transaction associated with main process
.PP
@80 Find the \fBOSTM\fP object in the Global shared map
.PP
@82 If object found then delete it
.PP
@84 Delete element from shared main_Process_Map_collection by object by the unique key, and the shaed_ptr will destroy automatically
.PP
@88 Delete main process from Process_map_collection 
.PP
Definition at line 68 of file TX\&.cpp\&.
.PP
References main_Process_Map_collection, and process_map_collection\&.
.PP
Referenced by TM::_TX_EXIT()\&.
.PP
.nf
68                    {
70     std::map<int, std::shared_ptr<OSTM>>::iterator main_Process_Map_collection_Iterator;
72     pid_t ppid = getppid();
74     std::map<pid_t, std::map< int, int >>::iterator process_map_collection_Iterator = TX::process_map_collection\&.find(ppid);
76     if (process_map_collection_Iterator != TX::process_map_collection\&.end()) {
78         for (auto current = process_map_collection_Iterator->second\&.begin(); current != process_map_collection_Iterator->second\&.end(); ++current) {
80             main_Process_Map_collection_Iterator = TX::main_Process_Map_collection\&.find(current->first);
82             if (main_Process_Map_collection_Iterator != TX::main_Process_Map_collection\&.end()){
84                 TX::main_Process_Map_collection\&.erase(main_Process_Map_collection_Iterator->first);      
85             }
86         }
88         TX::process_map_collection\&.erase(process_map_collection_Iterator->first);
89     }
90 }
.fi
.SS "void TX::store (std::shared_ptr< \fBOSTM\fP > object)"

.PP
@157 store void, receive an \fBOSTM\fP type shared pointer object to store the changes with the transaction copy object 
.PP
\fBParameters:\fP
.RS 4
\fIobject\fP std::shared_ptr<OSTM>, receiving a changed shared pointer, that was returned from the load function 
.RE
.PP
@159 RUNTIME ERROR\&. Check for null pointer ! Null pointer can cause segmentation fault!!!
.PP
@163 Declare and initialize Iterator for working_Map_collection
.PP
@165 Find copy object in working_Map_collection by the object unique ID
.PP
@167 If object found, then replace it
.PP
@169 Replace copy object in working_Map_collection associated with the unique ID key
.PP
@171 If error happes during store procees throw runtime error 
.PP
Definition at line 157 of file TX\&.cpp\&.
.PP
References working_Map_collection\&.
.PP
.nf
157                                          {
159     if(object == nullptr){
160         throw std::runtime_error(std::string("[RUNTIME ERROR : NULL POINTER IN STORE FUNCTION]") );
161     }
163     std::map< int, std::shared_ptr<OSTM> >::iterator working_Map_collection_Object_Shared_Pointer_Iterator;
165     working_Map_collection_Object_Shared_Pointer_Iterator = working_Map_collection\&.find(object->Get_Unique_ID());
167     if (working_Map_collection_Object_Shared_Pointer_Iterator != working_Map_collection\&.end()) {
169         working_Map_collection_Object_Shared_Pointer_Iterator->second = object;  
171     } else { throw std::runtime_error(std::string("[RUNTIME ERROR : NO OBJECT FOUND STORE FUNCTION, CANNOT STORE OBJECT]") );}
172 }
.fi
.SS "void TX::th_exit ()\fC [private]\fP"

.PP
@52 th_exit void, delete all std::shared_ptr<OSTM> elements from working_Map_collection, that store pointers to working objects Clean up all associated values by the thread delete from working_Map_collection, it is an automated function by the transactions
.PP
\fBParameters:\fP
.RS 4
\fIworking_Map_collection\fP std::map, store std::shared_ptr<OSTM> transaction pointers 
.RE
.PP
@54 If bigger than ZERO, means active nested transactions running in background, do not delete anything yet 
.PP
Definition at line 52 of file TX\&.cpp\&.
.PP
References _tx_nesting_level, and working_Map_collection\&.
.PP
Referenced by commit()\&.
.PP
.nf
52                  {
54     if (this->_tx_nesting_level > 0) {
55         /* Active nested transactions running in background, do not delete anything yet */
56     } else {
57         /* Remove all elements map entries from transaction and clear the map */
58         working_Map_collection\&.clear();
59     }
60 }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBTM\fP\fC [friend]\fP"

.PP
Definition at line 74 of file TX\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "int TX::_tx_nesting_level\fC [private]\fP"
_tx_nesting_level, store integer value represent the ttransaction nesting level 
.PP
Definition at line 101 of file TX\&.h\&.
.PP
Referenced by _decrease_tx_nesting(), _increase_tx_nesting(), commit(), th_exit(), and TX()\&.
.SS "std::map< int, std::shared_ptr< \fBOSTM\fP > > TX::main_Process_Map_collection\fC [static]\fP, \fC [private]\fP"
main_Process_Map_collection, STATIC GLOBAL MAP Collection to store \fBOSTM\fP parent based shared pointers to control/lock and compare objects version number within transactions 
.PP
Definition at line 105 of file TX\&.h\&.
.PP
Referenced by _register(), _release_object_lock(), commit(), and ostm_exit()\&.
.SS "std::map< pid_t, std::map< int, int > > TX::process_map_collection\fC [static]\fP, \fC [private]\fP"
process_map_collection, STATIC GLOBAL MAP Collection to store all process associated keys to find when deleting transactions 
.PP
Definition at line 109 of file TX\&.h\&.
.PP
Referenced by _print_all_tx(), _register(), and ostm_exit()\&.
.SS "std::mutex TX::register_Lock\fC [static]\fP, \fC [private]\fP"
register_Lock, std::mutex to control shared access on MAIN MAP 
.PP
Definition at line 117 of file TX\&.h\&.
.PP
Referenced by _register()\&.
.SS "int TX::test_counter = 0\fC [static]\fP"

.PP
Definition at line 82 of file TX\&.h\&.
.PP
Referenced by getTest_counter()\&.
.SS "std::thread::id TX::transaction_Number\fC [private]\fP"
transaction_Number, Returning the transaction number what is a registered thread number associated with the transaction 
.PP
Definition at line 97 of file TX\&.h\&.
.PP
Referenced by _get_tx_number(), and TX()\&.
.SS "std::map< int, std::shared_ptr<\fBOSTM\fP> > TX::working_Map_collection\fC [private]\fP"
working_Map_collection, Collection to store copy of \fBOSTM\fP parent based original Global shared pointers to make invisible changes during isolated transaction 
.PP
Definition at line 93 of file TX\&.h\&.
.PP
Referenced by _print_all_tx(), _register(), _release_object_lock(), commit(), load(), store(), and th_exit()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for C++ Software transactional Memory from the source code\&.
