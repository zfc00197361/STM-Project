.TH "md__media_zoltan__data_00_2018__i_t_carlow_00__modules_06__project__documents__git__sync__main__tests_for__linux__test01__r_e_a_d_m_e" 3 "Wed Mar 7 2018" "C++ Softwrae Transactional memory" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md__media_zoltan__data_00_2018__i_t_carlow_00__modules_06__project__documents__git__sync__main__tests_for__linux__test01__r_e_a_d_m_e \- README 
threadArraySize = 1 - 300 Nested transaction Test with any number of threads
.br
 Function \fInesting\fP is create a transaction and transfer between two objects
.br
 Then create a Transaction inside the transaction, (nested Transaction)
.br
 and inside the nested transaction invokes the \fItwo_account_transfer\fP transaction, that will be the third level inner transaction\&.
.br
 
.br
 TEST details: Used values :
.br
 Tanfer amount used in the transactions :
.br
 *transferAmount = 1
.br
 Number of threads used in the test application : 
.br
 *threadArraySize = 1 -10 - 300 specified in every test
.br
 
.br
 Six \fBOSTM\fP type smart pointer aib_ptr, boi_ptr, boa_ptr, swplc_ptr, ulster_ptr, unbl_ptr , these objects are inherites from \fBBANK\fP parent class\&.
.br
 Every thread used two object in the transaction within the \fInesting\fP function, and creates a nested transaction using the same objects\&.
.br
 Inside the nested transaction makes a function call to the \fItwo_account_transfer\fP function, which is creates a transaction and a nested transaction in the nested transaction\&.
.br
 So, every thread used the objects in four level deep transactions\&.
.br
 To make easyer to folow the calculation the transactions are using the objects in the same transfering oder, from-to\&.
.br
 
.br
 Test 1: using only 1 Thread with two objetcs aib_ptr, boi_ptr and tranfering 1 unit in every transaction :
.br
 thArray[i] = std::thread(\fInesting\fP, aib_ptr, boi_ptr, std::ref(tm), transferAmount);
.br
 Start values : Double value : 500 to each\&.
.br
 Nesting level 4\&.
.br
 After transactions : 
.br
.IP "\(bu" 2
To account : aib_ptr - Double value : 504 
.br

.IP "\(bu" 2
From account : boi_ptr - Double value : 496 
.br

.IP "\(bu" 2
version number 1\&. for all object used in transaction
.br
 
.br
 Test 2: using 10 Thread with two objetcs aib_ptr, boi_ptr and tranfering 1 unit in every transaction :
.br
 Start values : Double value : 500 to each\&.
.br
 Nesting level 4\&.
.br
 After transactions : 
.br

.IP "\(bu" 2
To account : aib_ptr - Double value : 540 
.br

.IP "\(bu" 2
From account : boi_ptr - Double value : 460 
.br

.IP "\(bu" 2
version number 10\&. for all object used in transaction
.br
 
.br
 Test 3: using 300 Thread with six objetcs aib_ptr, boi_ptr, boa_ptr, swplc_ptr, ulster_ptr, unbl_ptr and tranfering 1 unit in every transaction :
.br
 Every object will be used by 100 threads\&.
.br
 Start values : Double value : 500 to each\&.
.br
 Nesting level 4\&.
.br
 After transactions : 
.br

.IP "\(bu" 2
To account : aib_ptr - Double value : 900 
.br

.IP "\(bu" 2
From account : boi_ptr - Double value : 100 
.br

.IP "\(bu" 2
To account : boa_ptr - Double value : 900 
.br

.IP "\(bu" 2
From account : swplc_ptr - Double value : 100 
.br

.IP "\(bu" 2
To account : ulster_ptr - Double value : 900 
.br

.IP "\(bu" 2
From account : unbl_ptr - Double value : 100 
.br

.IP "\(bu" 2
version number 100\&. for all object used in transaction
.br
 
.PP

