.TH "TM" 3 "Sun Apr 1 2018" "CppUnit test STM" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TM \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <TM\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "std::shared_ptr< \fBTX\fP > const \fB_get_tx\fP ()"
.br
.RI "\fI_get_tx std::shared_ptr<TX>, returning a shared pointer with the transaction \fP"
.ti -1c
.RI "void \fB_TX_EXIT\fP ()"
.br
.RI "\fI_TX_EXIT void, the thread calls the ostm_exit function in the transaction, and clear all elements from the shared global collection associated with the main process \fP"
.ti -1c
.RI "std::map< std::thread::id, int > \fBget_thread_Map\fP ()"
.br
.RI "\fIget_thread_Map std::map, returning a map to store all unique ID from all objects from all transactions within the main process \fP"
.ti -1c
.RI "bool \fBoperator==\fP (const \fBTM\fP &rhs) const "
.br
.ti -1c
.RI "void \fBprint_all\fP ()"
.br
.RI "\fIONLY FOR TESTING print_all void, print out all object key from txMAP collection\&. \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBTM\fP & \fBInstance\fP ()"
.br
.RI "\fIScott Meyer's Singleton creation, what is thread safe\&. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBTM\fP & \fBoperator=\fP (const \fBTM\fP &)=delete"
.br
.RI "\fI\fBTM\fP copy operator, prevent from copying the Transaction Manager\&. \fP"
.ti -1c
.RI "void \fBregisterTX\fP ()"
.br
.RI "\fIget_thread_Map returning and map to insert to the process_map_collection as an inner value \fP"
.ti -1c
.RI "\fBTM\fP ()=default"
.br
.RI "\fI\fBTM\fP constructor, prevent from multiple instantiation\&. \fP"
.ti -1c
.RI "\fBTM\fP (const \fBTM\fP &)"
.br
.RI "\fI\fBTM\fP copy constructor, prevent from copying the Transaction Manager\&. \fP"
.ti -1c
.RI "\fB~TM\fP ()=default"
.br
.RI "\fI\fBTM\fP de-constructor, prevent from deletion\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::mutex \fBget_Lock\fP"
.br
.ti -1c
.RI "std::mutex \fBregister_Lock\fP"
.br
.ti -1c
.RI "std::map< std::thread::id, std::shared_ptr< \fBTX\fP > > \fBtxMap\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static pid_t \fB_tm_id\fP"
.br
.ti -1c
.RI "static std::map< pid_t, std::map< std::thread::id, int > > \fBprocess_map_collection\fP"
.br
.RI "\fISTATIC GLOBAL MAP Collection to store all process associated keys to find when deleting transactions\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 21 of file TM\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "TM::TM ()\fC [private]\fP, \fC [default]\fP"

.PP
\fBTM\fP constructor, prevent from multiple instantiation\&. 
.SS "TM::~TM ()\fC [private]\fP, \fC [default]\fP"

.PP
\fBTM\fP de-constructor, prevent from deletion\&. 
.SS "TM::TM (const \fBTM\fP &)\fC [private]\fP"

.PP
\fBTM\fP copy constructor, prevent from copying the Transaction Manager\&. 
.SH "Member Function Documentation"
.PP 
.SS "std::shared_ptr< \fBTX\fP > const TM::_get_tx ()"

.PP
_get_tx std::shared_ptr<TX>, returning a shared pointer with the transaction _get_tx std::shared_ptr<TX>, return a shared_ptr with the Transaction object, if \fBTX\fP not exists then create one, else increasing the nesting level  std::mutex, protect shared collection from critical section
.PP
\fBParameters:\fP
.RS 4
\fIguard\fP std::lock_guard, locks the register_Lock mutex, unlock automatically when goes out of the scope 
.RE
.PP

.PP
Definition at line 79 of file TM\&.cpp\&.
.PP
References get_Lock, registerTX(), and txMap\&.
.PP
Referenced by MyTestCAse::_collection_bject_(), MyTestCAse::_complex_transfer_(), client::_complex_transfer_(), client::_nesting_(), MyTestCAse::_nesting_(), MyTestCAse::_one_account_transfer_(), MyTestCAse::_six_account_transfer_(), client::_six_account_transfer_(), client::_two_account_transfer_(), MyTestCAse::_two_account_transfer_(), MyTestCAse::decrease_nesting(), MyTestCAse::decrease_nesting_fail(), MyTestCAse::increase_nesting(), MyTestCAse::increase_nesting_fail(), MyTestCAse::object_not_registered_throw_runtime_error(), MyTestCAse::register_null_pointer_throw_runtime_error(), and MyTestCAse::store_null_pointer_throw_runtime_error()\&.
.PP
.nf
80 {
81     std::lock_guard<std::mutex> guard(get_Lock);
82 
83     std::map<std::thread::id, std::shared_ptr<TX>>::iterator it = txMap\&.find(std::this_thread::get_id());
84     if(it == txMap\&.end())
85     {
86        registerTX();
87        it = txMap\&.find(std::this_thread::get_id());
88        
89     } else {
90         it->second->_increase_tx_nesting();
91     }
92     //it = txMap\&.find(std::this_thread::get_id());
93     
94 
95     return it->second;
96 
97 }
.fi
.SS "void TM::_TX_EXIT ()"

.PP
_TX_EXIT void, the thread calls the ostm_exit function in the transaction, and clear all elements from the shared global collection associated with the main process _TX_EXIT void, the thread calls the ostm_exit function in the transaction, and clear all elements from the shared global collection associated with the main process  tx \fBTX\fP, local object to function in transaction 
.PP
Definition at line 102 of file TM\&.cpp\&.
.PP
References TX::ostm_exit(), process_map_collection, and txMap\&.
.PP
Referenced by MyTestCAse::complex_threaded_functionality_hundred_threads(), MyTestCAse::complex_threaded_functionality_ten_threads(), MyTestCAse::multi_threaded_multiple_object_exchange_test(), MyTestCAse::multi_threaded_multiple_objects_test(), MyTestCAse::multi_threaded_single_object_test_with_ten_threads(), MyTestCAse::nested_hundred_thread_functionality(), MyTestCAse::nested_thousand_thread_functionality(), MyTestCAse::nested_transaction_object_test(), MyTestCAse::single_threaded_multiple_object_test(), MyTestCAse::threaded_functionality_hundred_threads(), MyTestCAse::threaded_functionality_hundred_threads_six_account(), MyTestCAse::threaded_functionality_thousand_threads(), MyTestCAse::threaded_functionality_thousand_threads_six_account(), MyTestCAse::two_object_transfer_complete(), and MyTestCAse::two_object_transfer_state_change()\&.
.PP
.nf
102                  {
103     TX tx(std::this_thread::get_id());
104     int ppid = getpid();
105     std::map<int, std::map< std::thread::id, int >>::iterator process_map_collection_Iterator = TM::process_map_collection\&.find(ppid);
106     if (process_map_collection_Iterator != TM::process_map_collection\&.end()) {
107 
108         for (auto current = process_map_collection_Iterator->second\&.begin(); current != process_map_collection_Iterator->second\&.end(); ++current) {
109             /*
110              * Delete all transaction associated with the actual main process
111              */
112             txMap\&.erase(current->first);
113         }
114         TM::process_map_collection\&.erase(ppid);
115 
116     }
117     tx\&.ostm_exit();
118 }
.fi
.SS "std::map< std::thread::id, int > TM::get_thread_Map ()"

.PP
get_thread_Map std::map, returning a map to store all unique ID from all objects from all transactions within the main process 
.PP
\fBParameters:\fP
.RS 4
\fIthread_Map\fP std::map< int, int >, 
.RE
.PP

.PP
Definition at line 134 of file TM\&.cpp\&.
.PP
Referenced by operator==(), registerTX(), and MyTestCAse::TM_get_thread_map()\&.
.PP
.nf
134                                               {
135     std::map< std::thread::id, int > thread_Map;
136     return thread_Map;
137 }
.fi
.SS "\fBTM\fP & TM::Instance ()\fC [static]\fP"

.PP
Scott Meyer's Singleton creation, what is thread safe\&. Instance \fBTM\fP, return the same singleton object to any process\&.
.PP
\fBParameters:\fP
.RS 4
\fI_instance\fP \fBTM\fP, static class reference to the instance of the Transaction Manager class 
.br
\fI_instance\fP ppid, assigning the process id whoever created the Singleton instance 
.RE
.PP

.PP
Definition at line 28 of file TM\&.cpp\&.
.PP
References _tm_id\&.
.PP
Referenced by MyTestCAse::compare_Transaction_Manager_singleton_instance()\&.
.PP
.nf
28                  {
29     static TM _instance;
30     _instance\&._tm_id = getpid();
31 
32     return _instance;
33 }
.fi
.SS "\fBTM\fP& TM::operator= (const \fBTM\fP &)\fC [private]\fP, \fC [delete]\fP"

.PP
\fBTM\fP copy operator, prevent from copying the Transaction Manager\&. 
.SS "bool TM::operator== (const \fBTM\fP & rhs) const\fC [inline]\fP"

.PP
Definition at line 91 of file TM\&.h\&.
.PP
References get_thread_Map()\&.
.PP
.nf
91                                          {
92         return &rhs == this;
93     }
.fi
.SS "void TM::print_all ()"

.PP
ONLY FOR TESTING print_all void, print out all object key from txMAP collection\&. ONLY FOR TESTING print_all void, prints all object in the txMap 
.PP
Definition at line 122 of file TM\&.cpp\&.
.PP
References get_Lock, and txMap\&.
.PP
.nf
122                   {
123     get_Lock\&.lock();
124     for (auto current = txMap\&.begin(); current != txMap\&.end(); ++current) {
125         std::cout << "KEY : " << current->first << std::endl;
126     }
127     get_Lock\&.unlock();
128 }
.fi
.SS "void TM::registerTX ()\fC [private]\fP"

.PP
get_thread_Map returning and map to insert to the process_map_collection as an inner value registerTX void, register a new \fBTX\fP Transaction object into ythe txMap/Transaction Map to manage all the transactions within the shared library
.PP
registerTX void, register transaction into txMap
.PP
\fBParameters:\fP
.RS 4
\fItxMap\fP std::map, collection to store all transaction created by the Transaction Manager 
.br
\fIregister_Lock\fP std::mutex, used by the lock_guard to protect shared map from race conditions 
.br
\fIguard\fP std::lock_guard, locks the register_Lock mutex, unlock automatically when goes out of the scope 
.RE
.PP

.PP
Definition at line 43 of file TM\&.cpp\&.
.PP
References get_thread_Map(), process_map_collection, register_Lock, and txMap\&.
.PP
Referenced by _get_tx()\&.
.PP
.nf
44 {
45     std::lock_guard<std::mutex> guard(register_Lock);
46     int ppid = getpid();
47     std::map<int, std::map< std::thread::id, int >>::iterator process_map_collection_Iterator = TM::process_map_collection\&.find(ppid);
48     if (process_map_collection_Iterator == TM::process_map_collection\&.end()) {
49         /*
50          * Register main process/application to the global map
51          */
52         std::map< std::thread::id, int >map = get_thread_Map();
53         TM::process_map_collection\&.insert({ppid, map});
54 
55     }
56     std::map<std::thread::id, std::shared_ptr < TX>>::iterator it = txMap\&.find(std::this_thread::get_id());
57     if (it == txMap\&.end()) {
58         std::shared_ptr<TX> _transaction_object(new TX(std::this_thread::get_id()));
59         txMap\&.insert({std::this_thread::get_id(), _transaction_object});
60         /*
61          * Get the map if registered first time
62          */
63         process_map_collection_Iterator = TM::process_map_collection\&.find(ppid);
64         /*
65          * Insert to the GLOBAL MAP as a helper to clean up at end of main process 
66          */
67         process_map_collection_Iterator->second\&.insert({std::this_thread::get_id(), 1});
68 
69     }
70 
71 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "int TM::_tm_id\fC [static]\fP, \fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fI_tm_id\fP pid_t, process id determine the actual process between process in the shared \fBOSTM\fP library 
.RE
.PP

.PP
Definition at line 67 of file TM\&.h\&.
.PP
Referenced by Instance()\&.
.SS "std::mutex TM::get_Lock\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIregister_Lock\fP std::mutex, used in the _get_tx function 
.RE
.PP

.PP
Definition at line 63 of file TM\&.h\&.
.PP
Referenced by _get_tx(), and print_all()\&.
.SS "std::map< int, std::map< std::thread::id, int > > TM::process_map_collection\fC [static]\fP, \fC [private]\fP"

.PP
STATIC GLOBAL MAP Collection to store all process associated keys to find when deleting transactions\&. 
.PP
\fBParameters:\fP
.RS 4
\fIprocess_map_collection\fP std::map
.br
\fIstatic\fP Global std::map process_map_collection store all transactional objects/pointers 
.RE
.PP

.PP
Definition at line 47 of file TM\&.h\&.
.PP
Referenced by _TX_EXIT(), and registerTX()\&.
.SS "std::mutex TM::register_Lock\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIregister_Lock\fP std::mutex, used in the registerTX function 
.RE
.PP

.PP
Definition at line 59 of file TM\&.h\&.
.PP
Referenced by registerTX()\&.
.SS "std::map<std::thread::id, std::shared_ptr<\fBTX\fP> > TM::txMap\fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fItxMap\fP std::map, store all transactional objects created with Transaction Manager 
.RE
.PP

.PP
Definition at line 42 of file TM\&.h\&.
.PP
Referenced by _get_tx(), _TX_EXIT(), print_all(), and registerTX()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CppUnit test STM from the source code\&.
