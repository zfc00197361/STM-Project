.TH "MyTestCAse" 3 "Sun Apr 1 2018" "CppUnit test STM" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MyTestCAse \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <MyTestCAse\&.h>\fP
.PP
Inherits TestCase\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fB_collection_bject_\fP (std::vector< std::shared_ptr< \fBOSTM\fP >> _customer_vec, \fBTM\fP &_tm, double _amount, int loop)"
.br
.RI "\fITest with a vector collection\&. \fP"
.ti -1c
.RI "void \fB_complex_transfer_\fP (std::shared_ptr< \fBOSTM\fP > _from_, std::shared_ptr< \fBOSTM\fP > _from_two_, std::vector< std::shared_ptr< \fBOSTM\fP >> _customer_vec, \fBTM\fP &_tm, double _amount)"
.br
.RI "\fIThis function use two single objects and a collection of objects in the transaction\&. The two single object transfer 1 - 1 (2) unit to every object in the collection\&. \fP"
.ti -1c
.RI "void \fB_nesting_\fP (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP &_tm, double _amount)"
.br
.RI "\fITesting nested transaction\&. \fP"
.ti -1c
.RI "void \fB_one_account_transfer_\fP (std::shared_ptr< \fBOSTM\fP > _to_, \fBTM\fP &_tm, double _amount)"
.br
.RI "\fIone object in the trasaction \fP"
.ti -1c
.RI "void \fB_six_account_transfer_\fP (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_one_, std::shared_ptr< \fBOSTM\fP > _from_two_, std::shared_ptr< \fBOSTM\fP > _from_three_, std::shared_ptr< \fBOSTM\fP > _from_four_, std::shared_ptr< \fBOSTM\fP > _from_five_, \fBTM\fP &_tm, double _amount)"
.br
.RI "\fITesting the transactions between six object\&. \fP"
.ti -1c
.RI "void \fB_two_account_transfer_\fP (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP &\fBtm\fP, double _amount)"
.br
.RI "\fITestin transaction between two pointer\&. \fP"
.ti -1c
.RI "void \fBcompare_Transaction_Manager_singleton_instance\fP ()"
.br
.RI "\fIThis testing function comparing the Transaction Manager to make sure the application using a Singleton object\&. \fP"
.ti -1c
.RI "void \fBcomplex_threaded_functionality_hundred_threads\fP ()"
.br
.ti -1c
.RI "void \fBcomplex_threaded_functionality_ten_threads\fP ()"
.br
.RI "\fITesting the library consistent behavior This test transfer 1 - 1 unit by 10 threads = 10 * 1 = 10 to evey object in the collection (-600) by single objects After transfer from account has -10 * 600 for both single objects and + 2 unit * 10 to every objects\&. \fP"
.ti -1c
.RI "void \fBdecrease_nesting\fP ()"
.br
.RI "\fITesting the nesting decrease function\&. \fP"
.ti -1c
.RI "void \fBdecrease_nesting_fail\fP ()"
.br
.RI "\fITesting the nesting decrease function to make sure the variable state changing\&. \fP"
.ti -1c
.RI "void \fBincrease_nesting\fP ()"
.br
.RI "\fITesting the nesting increase function\&. \fP"
.ti -1c
.RI "void \fBincrease_nesting_fail\fP ()"
.br
.RI "\fITesting the nesting increase function to make sure the variable state changing\&. \fP"
.ti -1c
.RI "void \fBmulti_threaded_multiple_object_exchange_test\fP ()"
.br
.RI "\fIDesign Manual document based tests Implementations\&. \fP"
.ti -1c
.RI "void \fBmulti_threaded_multiple_objects_test\fP ()"
.br
.RI "\fI
.IP "4." 4
Multi-threaded multiple Objects test\&. 
.PP
\fP"
.ti -1c
.RI "void \fBmulti_threaded_single_object_test_with_ten_threads\fP ()"
.br
.RI "\fI
.IP "2." 4
Multi-threaded single Object test with 10 threads\&. 
.PP
\fP"
.ti -1c
.RI "\fBMyTestCAse\fP ()"
.br
.ti -1c
.RI "\fBMyTestCAse\fP (const \fBMyTestCAse\fP &orig)"
.br
.ti -1c
.RI "void \fBnested_hundred_thread_functionality\fP ()"
.br
.RI "\fITesting the library consistent behavior Nested threaded function : 3 level of nesting, every thread transfer 3 unit from one object to the another object so, at end of the 100 thransaction the from object transfer 100 * 3 (300) to the another object 500 - 300 = 200 AND 500 + 300 = 800\&. \fP"
.ti -1c
.RI "void \fBnested_thousand_thread_functionality\fP ()"
.br
.RI "\fITesting the library consistent behavior Nested threaded function : 3 level of nesting, every thread transfer 3 unit from one object to the another object so, at end of the 100 thransaction the from object transfer 1000 * 3 (3000) to the another object 500 - 3000 = -2500 AND 500 + 3000 = 3500\&. \fP"
.ti -1c
.RI "void \fBnested_transaction_object_test\fP ()"
.br
.RI "\fITesting the library consistent behavior This test calls the nested function, where every thread transfer 3 unit in the nested transactions\&. Because this test in not threaded, the 3 level deep nesting transfer 3*20 = 60 from one object to the another object\&. 500 - 60 = 440 AND 500 + 60 = 560\&. \fP"
.ti -1c
.RI "void \fBobject_not_registered_throw_runtime_error\fP ()"
.br
.RI "\fIThe library function throws runtime error if the client application tries to load a working pointer from the library of a not registered pointer by the client application\&. Runtime error should be thrown\&. \fP"
.ti -1c
.RI "void \fBregister_null_pointer_throw_runtime_error\fP ()"
.br
.ti -1c
.RI "void \fBsetUp\fP ()"
.br
.ti -1c
.RI "void \fBsingle_threaded_multiple_object_test\fP ()"
.br
.RI "\fI
.IP "3." 4
Single-threaded multiple object test\&. 
.PP
\fP"
.ti -1c
.RI "void \fBstore_null_pointer_throw_runtime_error\fP ()"
.br
.RI "\fIThe test function throws runtime error if the client application tries to store the changed working pointer as a null pointer\&. Runtime error should be thrown\&. \fP"
.ti -1c
.RI "void \fBtearDown\fP ()"
.br
.ti -1c
.RI "void \fBthreaded_functionality_hundred_threads\fP ()"
.br
.ti -1c
.RI "void \fBthreaded_functionality_hundred_threads_six_account\fP ()"
.br
.RI "\fITesting the library consistent behavior This test transfer 1 unit by 100 threads from five account to one account After transfer from account has - 100*1 from the accounts, and to account has +100*5\&. \fP"
.ti -1c
.RI "void \fBthreaded_functionality_thousand_threads\fP ()"
.br
.RI "\fITesting the library consistent behavior This test transfer 1 unit by 1000 threads = 1000 *1 = 100 After transfer from account has -1000, and to account has +1000\&. \fP"
.ti -1c
.RI "void \fBthreaded_functionality_thousand_threads_six_account\fP ()"
.br
.RI "\fITesting the library consistent behavior This test transfer 1 unit by 1000 threads from five account to one account After transfer from account has - 1000*1 from the accounts, and to account has +1000*5\&. \fP"
.ti -1c
.RI "void \fBTM_get_thread_map\fP ()"
.br
.RI "\fIThis function testing the returned map from the Transaction Manager class\&. \fP"
.ti -1c
.RI "void \fBtwo_object_transfer_complete\fP ()"
.br
.RI "\fITesting the library consistent behavior Transfer between two objects : the from object transfer 20 to the another object 500 - 20 = 480 AND 500 + 20 = 520\&. \fP"
.ti -1c
.RI "void \fBtwo_object_transfer_state_change\fP ()"
.br
.RI "\fIThis function proves the objects states must change from the base values\&. \fP"
.ti -1c
.RI "virtual \fB~MyTestCAse\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "std::shared_ptr< \fBOSTM\fP > \fBaib_ptr\fP"
.br
.ti -1c
.RI "std::shared_ptr< \fBOSTM\fP > \fBboa_ptr\fP"
.br
.ti -1c
.RI "std::shared_ptr< \fBOSTM\fP > \fBboi_ptr\fP"
.br
.ti -1c
.RI "std::shared_ptr< \fBOSTM\fP > \fBswplc_ptr\fP"
.br
.ti -1c
.RI "\fBTM\fP & \fBtm\fP = \fBTM::Instance\fP()"
.br
.ti -1c
.RI "std::shared_ptr< \fBOSTM\fP > \fBulster_ptr\fP"
.br
.ti -1c
.RI "std::shared_ptr< \fBOSTM\fP > \fBunbl_ptr\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBthreaded_functionality_hundred_threads\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBthreaded_functionality_thousand_threads\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBthreaded_functionality_hundred_threads_six_account\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBthreaded_functionality_thousand_threads_six_account\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBnested_hundred_thread_functionality\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBnested_thousand_thread_functionality\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBcomplex_threaded_functionality_hundred_threads\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBcomplex_threaded_functionality_ten_threads\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBtwo_object_transfer_complete\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBtwo_object_transfer_state_change\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBnested_transaction_object_test\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBmulti_threaded_multiple_object_exchange_test\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBmulti_threaded_single_object_test_with_ten_threads\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBsingle_threaded_multiple_object_test\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBmulti_threaded_multiple_objects_test\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBincrease_nesting\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBincrease_nesting_fail\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBdecrease_nesting\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBdecrease_nesting_fail\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBtwo_object_transfer_state_change\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBcompare_Transaction_Manager_singleton_instance\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST\fP (\fBTM_get_thread_map\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST_EXCEPTION\fP (\fBregister_null_pointer_throw_runtime_error\fP, std::runtime_error)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST_EXCEPTION\fP (\fBobject_not_registered_throw_runtime_error\fP, std::runtime_error)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST_EXCEPTION\fP (\fBstore_null_pointer_throw_runtime_error\fP, std::runtime_error)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST_SUITE\fP (\fBMyTestCAse\fP)"
.br
.ti -1c
.RI "\fBCPPUNIT_TEST_SUITE_END\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBclient\fP * \fBa\fP"
.br
.ti -1c
.RI "\fBclient\fP * \fBb\fP"
.br
.ti -1c
.RI "\fBclient\fP * \fBc\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 18 of file MyTestCAse\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "MyTestCAse::MyTestCAse ()\fC [inline]\fP"

.PP
Definition at line 61 of file MyTestCAse\&.h\&.
.PP
.nf
61 {};
.fi
.SS "MyTestCAse::MyTestCAse (const \fBMyTestCAse\fP & orig)"

.PP
Definition at line 9 of file MyTestCAse\&.cpp\&.
.PP
.nf
9                                              {
10 }
.fi
.SS "MyTestCAse::~MyTestCAse ()\fC [virtual]\fP"

.PP
Definition at line 12 of file MyTestCAse\&.cpp\&.
.PP
.nf
12                         {
13 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void MyTestCAse::_collection_bject_ (std::vector< std::shared_ptr< \fBOSTM\fP >> _customer_vec, \fBTM\fP & _tm, double _amount, int loop)"

.PP
Test with a vector collection\&. 
.PP
\fBParameters:\fP
.RS 4
\fI_customer_vec\fP collection of \fBOSTM\fP type objects 
.br
\fI_tm\fP TRansaction Manager 
.br
\fI_amount\fP value used in the transaction 
.RE
.PP
Declare required pointers
.PP
Register customers accounts from the collection (vector)
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
Commit changes
.PP
Definition at line 20 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), and BANK::SetBalance()\&.
.PP
Referenced by multi_threaded_multiple_objects_test(), and single_threaded_multiple_object_test()\&.
.PP
.nf
20                                                                                                                    {
21     
22      std::shared_ptr<TX> tx = _tm\&._get_tx();
23 
27     std::shared_ptr<OSTM> _TO_OSTM_;
28     std::shared_ptr<BANK>  _TO_;
29 
30     bool done = false;
31     try {
32         while (!done) {
33             for (int i = 0; i < loop; ++i) {
34                 for (auto&& obj : _customer_vec) {
38                     // auto&& obj = _customer_vec\&.at(i);
39                     tx->_register(obj);
43                     _TO_ = std::dynamic_pointer_cast<BANK> (tx->load(obj));
47                     _TO_->SetBalance(_TO_->GetBalance() + (_amount));
51                     _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_);
55                     tx->store(_TO_OSTM_);
56                 }
57             }
61             done = tx->commit();
62         }
63     } catch (std::runtime_error& e) {
64         std::cout << e\&.what() << std::endl;
65     }
66 }
.fi
.SS "void MyTestCAse::_complex_transfer_ (std::shared_ptr< \fBOSTM\fP > _from_, std::shared_ptr< \fBOSTM\fP > _from_two_, std::vector< std::shared_ptr< \fBOSTM\fP >> _customer_vec, \fBTM\fP & _tm, double _amount)"

.PP
This function use two single objects and a collection of objects in the transaction\&. The two single object transfer 1 - 1 (2) unit to every object in the collection\&. 
.PP
\fBParameters:\fP
.RS 4
\fI<em>from</em>\fP pointer used in transaction 
.br
\fI<em>from_two</em>\fP pointer used in transaction 
.br
\fI_customer_vec\fP collection of pointer 
.br
\fI_tm\fP TRansaction Manager 
.br
\fI_amount\fP value used in the transaction 
.RE
.PP
Register the two single account
.PP
Declare required pointers
.PP
Register customers accounts from the collection (vector)
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
Commit changes
.PP
Definition at line 126 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), and BANK::SetBalance()\&.
.PP
Referenced by complex_threaded_functionality_hundred_threads(), and complex_threaded_functionality_ten_threads()\&.
.PP
.nf
126                                                                                                                                                                      {
127     std::shared_ptr<TX> tx = _tm\&._get_tx();
131     tx->_register(_from_);
132     tx->_register(_from_two_);
136     std::shared_ptr<OSTM> _FROM_OSTM_ONE_, _FROM_OSTM_TWO_, _TO_OSTM_;
137     std::shared_ptr<BANK> _FROM_, _FROM_TWO_, _TO_;
138 
139     bool done = false;
140     try {
141         while (!done) {
142             // for (int i = 0; i < vector_number; ++i) {
143             for (auto&& obj : _customer_vec) {
147                 // auto&& obj = _customer_vec\&.at(i);
148                 tx->_register(obj);
152                 _FROM_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_));
153                 _FROM_TWO_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_two_));
154                 _TO_ = std::dynamic_pointer_cast<BANK> (tx->load(obj));
158                 _FROM_->SetBalance(_FROM_->GetBalance() - _amount);
159                 _FROM_TWO_->SetBalance(_FROM_TWO_->GetBalance() - _amount);
160                 _TO_->SetBalance(_TO_->GetBalance() + (_amount * 2));
164                 _FROM_OSTM_ONE_ = std::dynamic_pointer_cast<OSTM> (_FROM_);
165                 _FROM_OSTM_TWO_ = std::dynamic_pointer_cast<OSTM> (_FROM_TWO_);
166                 _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_);
170                 tx->store(_FROM_OSTM_ONE_);
171                 tx->store(_FROM_OSTM_TWO_);
172                 tx->store(_TO_OSTM_);
173             }
177             done = tx->commit();
178         }
179     } catch (std::runtime_error& e) {
180         std::cout << e\&.what() << std::endl;
181     }
182 }
.fi
.SS "void MyTestCAse::_nesting_ (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP & _tm, double _amount)"

.PP
Testing nested transaction\&. 
.PP
\fBParameters:\fP
.RS 4
\fI<em>to</em>\fP pointer used in transaction 
.br
\fI<em>from</em>\fP pointer used in transaction 
.br
\fI_tm\fP Transaction Manager 
.br
\fI_amount\fP value used in the transaction 
.RE
.PP
Register the two single account
.PP
Declare required pointers
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
NESTED TRANSACTION
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
NESTED TRANSACTION IN THE NESTED TRANSACTION \fItwo_account_transfer\fP function call
.PP
Commit changes
.PP
Definition at line 320 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), _two_account_transfer_(), and BANK::SetBalance()\&.
.PP
Referenced by nested_hundred_thread_functionality(), and nested_thousand_thread_functionality()\&.
.PP
.nf
320                                                                                                         {
321     std::shared_ptr<TX> tx = _tm\&._get_tx();
325     tx->_register(_to_);
326     tx->_register(_from_);
330     std::shared_ptr<BANK> _TO_BANK_, _FROM_BANK_;
331     std::shared_ptr<OSTM> _TO_OSTM_, _FROM_OSTM_;
332 
333 
334     bool done = false;
335     try {
336         while (!done) {
340             _TO_BANK_ = std::dynamic_pointer_cast<BANK> (tx->load(_to_));
341             _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_));
345             _TO_BANK_->SetBalance(_TO_BANK_->GetBalance() + _amount);
346             _FROM_BANK_->SetBalance(_FROM_BANK_->GetBalance() - _amount);
350             _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_BANK_);
351             _FROM_OSTM_ = std::dynamic_pointer_cast<OSTM> (_FROM_BANK_);
355             tx->store(_TO_OSTM_);
356             tx->store(_FROM_OSTM_);
357 
361             std::shared_ptr<TX> txTwo = _tm\&._get_tx();
362 
363             bool nestedDone = false;
364             while (!nestedDone) {
365                 _TO_BANK_ = std::dynamic_pointer_cast<BANK> (txTwo->load(_to_));
366                 _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (txTwo->load(_from_));
370                 _TO_BANK_->SetBalance(_TO_BANK_->GetBalance() + _amount);
371                 _FROM_BANK_->SetBalance(_FROM_BANK_->GetBalance() - _amount);
375                 _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_BANK_);
376                 _FROM_OSTM_ = std::dynamic_pointer_cast<OSTM> (_FROM_BANK_);
380                 txTwo->store(_TO_OSTM_);
381                 txTwo->store(_FROM_OSTM_);
386                 _two_account_transfer_(_to_, _from_, _tm, _amount);
387 
388                 nestedDone = txTwo->commit();
389             }
390 
394             done = tx->commit();
395         }
396     } catch (std::runtime_error& e) {
397         std::cout << e\&.what() << std::endl;
398     }
399 }
.fi
.SS "void MyTestCAse::_one_account_transfer_ (std::shared_ptr< \fBOSTM\fP > _to_, \fBTM\fP & _tm, double _amount)"

.PP
one object in the trasaction 
.PP
\fBParameters:\fP
.RS 4
\fI<em>to</em>\fP pointer used in transaction 
.br
\fI_tm\fP TRansaction Manager 
.br
\fI_amount\fP value used in the transaction 
.RE
.PP
Register the two single account
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
Commit changes
.PP
Definition at line 74 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), BANK::SetBalance(), and tm\&.
.PP
Referenced by multi_threaded_single_object_test_with_ten_threads()\&.
.PP
.nf
74                                                                                         {
75      std::shared_ptr<TX> tx = tm\&._get_tx();
79     tx->_register(_to_);
80     
81     std::shared_ptr<OSTM> _TO_OSTM_;
82     std::shared_ptr<BANK> _TO_;
83     
84     try {
85         bool done = false;
86         while (!done) {
90             _TO_ = std::dynamic_pointer_cast<BANK> (tx->load(_to_));
94             _TO_->SetBalance(_TO_->GetBalance() + (_amount ));
95 
99             _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_);
103             tx->store(_TO_OSTM_);
104 
108             done = tx->commit();
109         }
110     } catch (std::runtime_error& e) {
111         std::cout << e\&.what() << std::endl;
112     }
113     
114     
115     
116 }
.fi
.SS "void MyTestCAse::_six_account_transfer_ (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_one_, std::shared_ptr< \fBOSTM\fP > _from_two_, std::shared_ptr< \fBOSTM\fP > _from_three_, std::shared_ptr< \fBOSTM\fP > _from_four_, std::shared_ptr< \fBOSTM\fP > _from_five_, \fBTM\fP & _tm, double _amount)"

.PP
Testing the transactions between six object\&. 
.PP
\fBParameters:\fP
.RS 4
\fI<em>to</em>\fP pointer used in transaction 
.br
\fI<em>from_one</em>\fP pointer used in transaction 
.br
\fI<em>from_two</em>\fP pointer used in transaction 
.br
\fI<em>from_three</em>\fP pointer used in transaction 
.br
\fI<em>from_four</em>\fP pointer used in transaction 
.br
\fI<em>from_five</em>\fP pointer used in transaction 
.br
\fI_tm\fP Transaction Manager 
.br
\fI_amount\fP value used in the transaction 
.RE
.PP
Register the two single account
.PP
Required pointers to use in transaction
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
Commit changes
.PP
Definition at line 194 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), and BANK::SetBalance()\&.
.PP
Referenced by threaded_functionality_hundred_threads_six_account(), and threaded_functionality_thousand_threads_six_account()\&.
.PP
.nf
194                                                                                                                                                                                                                                                              {
195     std::shared_ptr<TX> tx = _tm\&._get_tx();
199     tx->_register(_to_);
200     tx->_register(_from_one_);
201     tx->_register(_from_two_);
202     tx->_register(_from_three_);
203     tx->_register(_from_four_);
204     tx->_register(_from_five_);
205 
209     std::shared_ptr<OSTM> _TO_OSTM, _FROM_ONE_OSTM, _FROM_TWO_OSTM, _FROM_THREE_OSTM, _FROM_FOUR_OSTM, _FROM_FIVE_OSTM;
210     std::shared_ptr<BANK> _TO_, _FROM_ONE_, _FROM_TWO_, _FROM_THREE_, _FROM_FOUR_, _FROM_FIVE_;
211     try {
212         bool done = false;
213         while (!done) {
217             _TO_ = std::dynamic_pointer_cast<BANK> (tx->load(_to_));
218             _FROM_ONE_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_one_));
219             _FROM_TWO_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_two_));
220             _FROM_THREE_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_three_));
221             _FROM_FOUR_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_four_));
222             _FROM_FIVE_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_five_));
226             _TO_->SetBalance(_TO_->GetBalance() + (_amount * 5));
227             _FROM_ONE_->SetBalance(_FROM_ONE_->GetBalance() - _amount);
228             _FROM_TWO_->SetBalance(_FROM_TWO_->GetBalance() - _amount);
229             _FROM_THREE_->SetBalance(_FROM_THREE_->GetBalance() - _amount);
230             _FROM_FOUR_->SetBalance(_FROM_FOUR_->GetBalance() - _amount);
231             _FROM_FIVE_->SetBalance(_FROM_FIVE_->GetBalance() - _amount);
235             _TO_OSTM = std::dynamic_pointer_cast<OSTM> (_TO_);
236             _FROM_ONE_OSTM = std::dynamic_pointer_cast<OSTM> (_FROM_ONE_);
237             _FROM_TWO_OSTM = std::dynamic_pointer_cast<OSTM> (_FROM_TWO_);
238             _FROM_THREE_OSTM = std::dynamic_pointer_cast<OSTM> (_FROM_THREE_);
239             _FROM_FOUR_OSTM = std::dynamic_pointer_cast<OSTM> (_FROM_FOUR_);
240             _FROM_FIVE_OSTM = std::dynamic_pointer_cast<OSTM> (_FROM_FIVE_);
244             tx->store(_TO_OSTM);
245             tx->store(_FROM_ONE_OSTM);
246             tx->store(_FROM_TWO_OSTM);
247             tx->store(_FROM_THREE_OSTM);
248             tx->store(_FROM_FOUR_OSTM);
249             tx->store(_FROM_FIVE_OSTM);
253             done = tx->commit();
254         }
255     } catch (std::runtime_error& e) {
256         std::cout << e\&.what() << std::endl;
257     }
258 }
.fi
.SS "void MyTestCAse::_two_account_transfer_ (std::shared_ptr< \fBOSTM\fP > _to_, std::shared_ptr< \fBOSTM\fP > _from_, \fBTM\fP & tm, double _amount)"

.PP
Testin transaction between two pointer\&. 
.PP
\fBParameters:\fP
.RS 4
\fI<em>to</em>\fP pointer used in transaction 
.br
\fI<em>from</em>\fP pointer used in transaction 
.br
\fItm\fP TRansaction Manager 
.br
\fI_amount\fP value used in the transaction 
.RE
.PP
Register the two single account
.PP
Declare required pointers
.PP
From std::shared_ptr<OSTM> to std::shared_ptr<BANK> to access the virtual methods
.PP
Make changes with the objects
.PP
From std::shared_ptr<BANK> to std::shared_ptr<OSTM> to store the memory spaces
.PP
Store changes
.PP
Commit changes
.PP
Definition at line 266 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), and BANK::SetBalance()\&.
.PP
Referenced by _nesting_(), multi_threaded_multiple_object_exchange_test(), threaded_functionality_hundred_threads(), and threaded_functionality_thousand_threads()\&.
.PP
.nf
266                                                                                                                      {
267 
268     std::shared_ptr<TX> tx = tm\&._get_tx();
272     tx->_register(_to_);
273     tx->_register(_from_);
277     std::shared_ptr<BANK> _TO_BANK_, _FROM_BANK_;
278     std::shared_ptr<OSTM> _TO_OSTM_, _FROM_OSTM_;
279 
280     bool done = false;
281     try {
282         while (!done) {
286             _TO_BANK_ = std::dynamic_pointer_cast<BANK> (tx->load(_to_));
287             _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (tx->load(_from_));
291             _TO_BANK_->SetBalance(_TO_BANK_->GetBalance() + _amount);
292             _FROM_BANK_->SetBalance(_FROM_BANK_->GetBalance() - _amount);
296             _TO_OSTM_ = std::dynamic_pointer_cast<OSTM> (_TO_BANK_);
297             _FROM_OSTM_ = std::dynamic_pointer_cast<OSTM> (_FROM_BANK_);
301             tx->store(_TO_OSTM_);
302             tx->store(_FROM_OSTM_);
303 
307             done = tx->commit();
308         }
309     } catch (std::runtime_error& e) {
310         std::cout << e\&.what() << std::endl;
311     }
312 }
.fi
.SS "void MyTestCAse::compare_Transaction_Manager_singleton_instance ()"

.PP
This testing function comparing the Transaction Manager to make sure the application using a Singleton object\&. 
.PP
Definition at line 896 of file MyTestCAse\&.cpp\&.
.PP
References TM::Instance(), and tm\&.
.PP
.nf
896                                                                {
897     TM& tm_copy = TM::Instance();
898     CPPUNIT_ASSERT( tm == tm_copy );
899 }
.fi
.SS "void MyTestCAse::complex_threaded_functionality_hundred_threads ()"
\\ brief Testing the library consistent behavior LONG RUNNING PROCESS !!!! 1\&.5 - 2 Minutes !!! This test transfer 1 - 1 unit by 100 threads = 100 * 1 = 100 to every object in the collection (-6000) by single objects After transfer from account has -100 * 600 for both single objects and + 2 unit * 100 to every objects 
.PP
Definition at line 412 of file MyTestCAse\&.cpp\&.
.PP
References _complex_transfer_(), TM::_TX_EXIT(), aib_ptr, boi_ptr, and tm\&.
.PP
.nf
412                                                                {
413     tm\&._TX_EXIT();
414      std::vector<std::shared_ptr < OSTM>>_customer_vec; 
415      for (int i = 0; i < 600; ++i) {
416         if (i % 6 == 0) {
417             std::shared_ptr<OSTM> sharedptr(new AIB(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
418             _customer_vec\&.push_back(std::move(sharedptr));
419         } else if (i % 5 == 0) {
420             std::shared_ptr<OSTM> sharedptr(new BOI(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
421             _customer_vec\&.push_back(std::move(sharedptr));
422         } else if (i % 4 == 0) {
423             std::shared_ptr<OSTM> sharedptr(new BOA(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
424             _customer_vec\&.push_back(std::move(sharedptr));
425         } else if (i % 3 == 0) {
426             std::shared_ptr<OSTM> sharedptr(new SWBPLC(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
427             _customer_vec\&.push_back(std::move(sharedptr));
428         } else if (i % 2 == 0) {
429             std::shared_ptr<OSTM> sharedptr(new ULSTER(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
430             _customer_vec\&.push_back(std::move(sharedptr));
431         } else if (i % 1 == 0) {
432             std::shared_ptr<OSTM> sharedptr(new UNBL(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
433             _customer_vec\&.push_back(std::move(sharedptr));
434         }
435     }
436     std::shared_ptr<BANK> _FROM_BANK_;
437     std::shared_ptr<BANK> _TO_BANK_;
438     
439     std::shared_ptr<OSTM> aib_ptr(new AIB(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
440     std::shared_ptr<OSTM> boi_ptr(new BOI(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
441     
442     int transferAmount = 1;
443     int threadArraySize = 100; 
444     std::thread thArray[threadArraySize];
445    
446     for (int i = 0; i < threadArraySize; ++i) {
447         thArray[i] = std::thread(&MyTestCAse::_complex_transfer_, this, aib_ptr, boi_ptr, std::ref(_customer_vec),  std::ref(tm), transferAmount);
448     }
449     
450     for (int i = 0; i < threadArraySize; ++i) {
451         thArray[i]\&.join();
452     }
453     
454     _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (boi_ptr);
455     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (aib_ptr);
456     
457     CPPUNIT_ASSERT(_FROM_BANK_->GetBalance() == -59500);
458     CPPUNIT_ASSERT(_TO_BANK_->GetBalance() == -59500);
459     
460 }
.fi
.SS "void MyTestCAse::complex_threaded_functionality_ten_threads ()"

.PP
Testing the library consistent behavior This test transfer 1 - 1 unit by 10 threads = 10 * 1 = 10 to evey object in the collection (-600) by single objects After transfer from account has -10 * 600 for both single objects and + 2 unit * 10 to every objects\&. 
.PP
Definition at line 467 of file MyTestCAse\&.cpp\&.
.PP
References _complex_transfer_(), TM::_TX_EXIT(), aib_ptr, boi_ptr, and tm\&.
.PP
.nf
467                                                            {
468     tm\&._TX_EXIT();
469     std::vector<std::shared_ptr < OSTM>>_customer_vec; 
470      for (int i = 0; i < 600; ++i) {
471         if (i % 6 == 0) {
472             std::shared_ptr<OSTM> sharedptr(new AIB(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
473             _customer_vec\&.push_back(std::move(sharedptr));
474         } else if (i % 5 == 0) {
475             std::shared_ptr<OSTM> sharedptr(new BOI(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
476             _customer_vec\&.push_back(std::move(sharedptr));
477         } else if (i % 4 == 0) {
478             std::shared_ptr<OSTM> sharedptr(new BOA(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
479             _customer_vec\&.push_back(std::move(sharedptr));
480         } else if (i % 3 == 0) {
481             std::shared_ptr<OSTM> sharedptr(new SWBPLC(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
482             _customer_vec\&.push_back(std::move(sharedptr));
483         } else if (i % 2 == 0) {
484             std::shared_ptr<OSTM> sharedptr(new ULSTER(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
485             _customer_vec\&.push_back(std::move(sharedptr));
486         } else if (i % 1 == 0) {
487             std::shared_ptr<OSTM> sharedptr(new UNBL(i, 50, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
488             _customer_vec\&.push_back(std::move(sharedptr));
489         }
490     }
491     std::shared_ptr<BANK> _FROM_BANK_;
492     std::shared_ptr<BANK> _TO_BANK_;
493     
494     std::shared_ptr<OSTM> aib_ptr(new AIB(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
495     std::shared_ptr<OSTM> boi_ptr(new BOI(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
496     
497     int transferAmount = 1;
498     int threadArraySize = 10; 
499     std::thread thArray[threadArraySize];
500 
501     for (int i = 0; i < threadArraySize; ++i) {
502         thArray[i] = std::thread(&MyTestCAse::_complex_transfer_, this, aib_ptr, boi_ptr, std::ref(_customer_vec),  std::ref(tm), transferAmount);
503     }
504     
505     for (int i = 0; i < threadArraySize; ++i) {
506         thArray[i]\&.join();
507     }
508     
509     _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (boi_ptr);
510     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (aib_ptr);
511     
512     CPPUNIT_ASSERT(_FROM_BANK_->GetBalance() == -5500);
513     CPPUNIT_ASSERT(_TO_BANK_->GetBalance() == -5500);
514     
515 }
.fi
.SS "MyTestCAse::CPPUNIT_TEST (\fBthreaded_functionality_hundred_threads\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBthreaded_functionality_thousand_threads\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBthreaded_functionality_hundred_threads_six_account\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBthreaded_functionality_thousand_threads_six_account\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBnested_hundred_thread_functionality\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBnested_thousand_thread_functionality\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBcomplex_threaded_functionality_hundred_threads\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBcomplex_threaded_functionality_ten_threads\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBtwo_object_transfer_complete\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBtwo_object_transfer_state_change\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBnested_transaction_object_test\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBmulti_threaded_multiple_object_exchange_test\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBmulti_threaded_single_object_test_with_ten_threads\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBsingle_threaded_multiple_object_test\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBmulti_threaded_multiple_objects_test\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBincrease_nesting\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBincrease_nesting_fail\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBdecrease_nesting\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBdecrease_nesting_fail\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBtwo_object_transfer_state_change\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBcompare_Transaction_Manager_singleton_instance\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST (\fBTM_get_thread_map\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST_EXCEPTION (\fBregister_null_pointer_throw_runtime_error\fP, std::runtime_error)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST_EXCEPTION (\fBobject_not_registered_throw_runtime_error\fP, std::runtime_error)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST_EXCEPTION (\fBstore_null_pointer_throw_runtime_error\fP, std::runtime_error)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST_SUITE (\fBMyTestCAse\fP)\fC [private]\fP"

.SS "MyTestCAse::CPPUNIT_TEST_SUITE_END ()\fC [private]\fP"

.SS "void MyTestCAse::decrease_nesting ()"

.PP
Testing the nesting decrease function\&. 
.PP
Definition at line 853 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), and tm\&.
.PP
.nf
853                                  {
854     
855     std::shared_ptr<TX> tx = tm\&._get_tx();
856     tx->setTx_nesting_level(10);
857     tx->_decrease_tx_nesting();
858     tx->_decrease_tx_nesting();
859     tx->_decrease_tx_nesting();
860     
861     CPPUNIT_ASSERT( tx->getTx_nesting_level() == 7);
862     tx->_decrease_tx_nesting();
863     CPPUNIT_ASSERT( tx->getTx_nesting_level() == 6);
864 }
.fi
.SS "void MyTestCAse::decrease_nesting_fail ()"

.PP
Testing the nesting decrease function to make sure the variable state changing\&. 
.PP
Definition at line 881 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), and tm\&.
.PP
.nf
881                                       {
882     
883     std::shared_ptr<TX> tx = tm\&._get_tx();
884     tx->setTx_nesting_level(10);
885     tx->_decrease_tx_nesting();
886     tx->_decrease_tx_nesting();
887     tx->_decrease_tx_nesting();
888     
889     CPPUNIT_ASSERT( !(tx->getTx_nesting_level() == 10));
890     tx->_decrease_tx_nesting();
891     CPPUNIT_ASSERT( !(tx->getTx_nesting_level() == 12));
892 }
.fi
.SS "void MyTestCAse::increase_nesting ()"

.PP
Testing the nesting increase function\&. 
.PP
Definition at line 841 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), and tm\&.
.PP
.nf
841                                  {
842     std::shared_ptr<TX> tx = tm\&._get_tx();
843     tx->setTx_nesting_level(0);
844     tx->_increase_tx_nesting();
845     tx->_increase_tx_nesting();
846     tx->_increase_tx_nesting();
847 
848     CPPUNIT_ASSERT( tx->getTx_nesting_level() == 3);
849 }
.fi
.SS "void MyTestCAse::increase_nesting_fail ()"

.PP
Testing the nesting increase function to make sure the variable state changing\&. 
.PP
Definition at line 868 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), and tm\&.
.PP
.nf
868                                       {
869     std::shared_ptr<TX> tx = tm\&._get_tx();
870     tx->setTx_nesting_level(0);
871     tx->_increase_tx_nesting();
872     tx->_increase_tx_nesting();
873     tx->_increase_tx_nesting();
874 
875     CPPUNIT_ASSERT( !(tx->getTx_nesting_level() == 0));
876 
877 }
.fi
.SS "void MyTestCAse::multi_threaded_multiple_object_exchange_test ()"

.PP
Design Manual document based tests Implementations\&. 
.IP "1." 4
Single thread multiple transactional object exchange test
.IP "2." 4
Multi-threaded single Object test with 10 threads\&.
.IP "3." 4
Single-threaded multiple object test\&.
.IP "4." 4
Multi-threaded multiple Objects test\&.
.PP
.IP "1." 4
Single thread multiple transactional object exchange test 
.PP

.PP
Definition at line 922 of file MyTestCAse\&.cpp\&.
.PP
References _two_account_transfer_(), TM::_TX_EXIT(), aib_ptr, boi_ptr, and tm\&.
.PP
.nf
922                                                              {
923     //ten threads using same objects
924     tm\&._TX_EXIT();
925     std::shared_ptr<BANK> _FROM_BANK_;
926     std::shared_ptr<BANK> _TO_BANK_;
927     
928     std::shared_ptr<OSTM> aib_ptr(new AIB(100, 100, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
929     std::shared_ptr<OSTM> boi_ptr(new BOI(200, 100, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
930     
931     int transferAmount = 5;
932     int threadArraySize = 10; 
933     std::thread thArray[threadArraySize];
934 
935     for (int i = 0; i < threadArraySize; ++i) {
936         thArray[i] = std::thread(&MyTestCAse::_two_account_transfer_, this, aib_ptr, boi_ptr, std::ref(tm), transferAmount);
937     }
938     
939     for (int i = 0; i < threadArraySize; ++i) {
940         thArray[i]\&.join();
941     }
942     
943     _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (boi_ptr);
944     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (aib_ptr);
945 
946     CPPUNIT_ASSERT(_FROM_BANK_->GetBalance() == 50);
947     CPPUNIT_ASSERT(_TO_BANK_->GetBalance() == 150);
948     
949 }
.fi
.SS "void MyTestCAse::multi_threaded_multiple_objects_test ()"

.PP

.IP "4." 4
Multi-threaded multiple Objects test\&. 
.PP

.PP
Definition at line 1040 of file MyTestCAse\&.cpp\&.
.PP
References _collection_bject_(), TM::_TX_EXIT(), and tm\&.
.PP
.nf
1040                                                      {
1041     //three threads all thread use different objects 
1042 
1043     tm\&._TX_EXIT();
1044     std::vector<std::shared_ptr < OSTM>>_customer_vec; 
1045      for (int i = 0; i < 10; ++i) {
1046         if (i % 6 == 0) {
1047             std::shared_ptr<OSTM> sharedptr(new AIB(i, 10, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
1048             _customer_vec\&.push_back(std::move(sharedptr));
1049         } else if (i % 5 == 0) {
1050             std::shared_ptr<OSTM> sharedptr(new BOI(i, 10, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
1051             _customer_vec\&.push_back(std::move(sharedptr));
1052         } else if (i % 4 == 0) {
1053             std::shared_ptr<OSTM> sharedptr(new BOA(i, 10, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
1054             _customer_vec\&.push_back(std::move(sharedptr));
1055         } else if (i % 3 == 0) {
1056             std::shared_ptr<OSTM> sharedptr(new SWBPLC(i, 10, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
1057             _customer_vec\&.push_back(std::move(sharedptr));
1058         } else if (i % 2 == 0) {
1059             std::shared_ptr<OSTM> sharedptr(new ULSTER(i, 10, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
1060             _customer_vec\&.push_back(std::move(sharedptr));
1061         } else if (i % 1 == 0) {
1062             std::shared_ptr<OSTM> sharedptr(new UNBL(i, 10, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
1063             _customer_vec\&.push_back(std::move(sharedptr));
1064         }
1065     }
1066     std::shared_ptr<BANK> _one_, _two_, _three_, _four_, _five_, _six_;
1067     int loop = 1;
1068     int transferAmount = 1;
1069     int threadArraySize = 10; 
1070     std::thread thArray[threadArraySize];
1071 
1072     for (int i = 0; i < threadArraySize; ++i) { 
1073         thArray[i] = std::thread(&MyTestCAse::_collection_bject_, this, std::ref(_customer_vec),  std::ref(tm), transferAmount , loop);
1074     }
1075     
1076     for (int i = 0; i < threadArraySize; ++i) {
1077         thArray[i]\&.join();
1078     }
1079     
1080     _one_ = std::dynamic_pointer_cast<BANK> (_customer_vec[0]);
1081     _two_ = std::dynamic_pointer_cast<BANK> (_customer_vec[1]);
1082     _three_ = std::dynamic_pointer_cast<BANK> (_customer_vec[2]);
1083     _four_ = std::dynamic_pointer_cast<BANK> (_customer_vec[3]);
1084     _five_ = std::dynamic_pointer_cast<BANK> (_customer_vec[4]);
1085     _six_ = std::dynamic_pointer_cast<BANK> (_customer_vec[5]);
1086  
1087     CPPUNIT_ASSERT(_one_->GetBalance() == 20);
1088     CPPUNIT_ASSERT(_two_->GetBalance() == 20);
1089     CPPUNIT_ASSERT(_three_->GetBalance() == 20);
1090     CPPUNIT_ASSERT(_four_->GetBalance() == 20);
1091     CPPUNIT_ASSERT(_five_->GetBalance() == 20);
1092     CPPUNIT_ASSERT(_six_->GetBalance() == 20);
1093 }
.fi
.SS "void MyTestCAse::multi_threaded_single_object_test_with_ten_threads ()"

.PP

.IP "2." 4
Multi-threaded single Object test with 10 threads\&. 
.PP

.PP
Definition at line 954 of file MyTestCAse\&.cpp\&.
.PP
References _one_account_transfer_(), TM::_TX_EXIT(), aib_ptr, and tm\&.
.PP
.nf
954                                                                    {
955     //one object ten threads
956     tm\&._TX_EXIT();
957     std::shared_ptr<BANK> _TO_BANK_;
958     
959     std::shared_ptr<OSTM> aib_ptr(new AIB(100, 100, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
960     
961     int transferAmount = 1;
962     int threadArraySize = 10; 
963     std::thread thArray[threadArraySize];
964 
965     for (int i = 0; i < threadArraySize; ++i) {
966         thArray[i] = std::thread(&MyTestCAse::_one_account_transfer_, this, aib_ptr, std::ref(tm), transferAmount);
967     }
968     
969     for (int i = 0; i < threadArraySize; ++i) {
970         thArray[i]\&.join();
971     }
972     
973 
974     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (aib_ptr);
975     
976     CPPUNIT_ASSERT(_TO_BANK_->GetBalance() == 110);
977 
978 }
.fi
.SS "void MyTestCAse::nested_hundred_thread_functionality ()"

.PP
Testing the library consistent behavior Nested threaded function : 3 level of nesting, every thread transfer 3 unit from one object to the another object so, at end of the 100 thransaction the from object transfer 100 * 3 (300) to the another object 500 - 300 = 200 AND 500 + 300 = 800\&. 
.PP
Definition at line 680 of file MyTestCAse\&.cpp\&.
.PP
References _nesting_(), TM::_TX_EXIT(), aib_ptr, boi_ptr, and tm\&.
.PP
.nf
680                                                     {
681     tm\&._TX_EXIT();
682     std::shared_ptr<BANK> _FROM_BANK_;
683     std::shared_ptr<BANK> _TO_BANK_;
684     
685     std::shared_ptr<OSTM> aib_ptr(new AIB(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
686     std::shared_ptr<OSTM> boi_ptr(new BOI(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
687     
688     int transferAmount = 1;
689     int threadArraySize = 100; 
690     std::thread thArray[threadArraySize];
691 
692     for (int i = 0; i < threadArraySize; ++i) {
693         thArray[i] = std::thread(&MyTestCAse::_nesting_, this, aib_ptr, boi_ptr, std::ref(tm), transferAmount);
694     }
695     
696     for (int i = 0; i < threadArraySize; ++i) {
697         thArray[i]\&.join();
698     }
699     
700     _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (boi_ptr);
701     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (aib_ptr);
702     
703     CPPUNIT_ASSERT(_FROM_BANK_->GetBalance() == 200);
704     CPPUNIT_ASSERT(_TO_BANK_->GetBalance() == 800);
705     
706 }
.fi
.SS "void MyTestCAse::nested_thousand_thread_functionality ()"

.PP
Testing the library consistent behavior Nested threaded function : 3 level of nesting, every thread transfer 3 unit from one object to the another object so, at end of the 100 thransaction the from object transfer 1000 * 3 (3000) to the another object 500 - 3000 = -2500 AND 500 + 3000 = 3500\&. 
.PP
Definition at line 715 of file MyTestCAse\&.cpp\&.
.PP
References _nesting_(), TM::_TX_EXIT(), aib_ptr, boi_ptr, and tm\&.
.PP
.nf
715                                                      {
716     tm\&._TX_EXIT();
717     std::shared_ptr<BANK> _FROM_BANK_;
718     std::shared_ptr<BANK> _TO_BANK_;
719     
720     std::shared_ptr<OSTM> aib_ptr(new AIB(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
721     std::shared_ptr<OSTM> boi_ptr(new BOI(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
722     
723     int transferAmount = 1;
724     int threadArraySize = 1000; 
725     std::thread thArray[threadArraySize];
726 
727     for (int i = 0; i < threadArraySize; ++i) {
728         thArray[i] = std::thread(&MyTestCAse::_nesting_, this, aib_ptr, boi_ptr, std::ref(tm), transferAmount);
729     }
730     
731     for (int i = 0; i < threadArraySize; ++i) {
732         thArray[i]\&.join();
733     }
734     
735     _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (boi_ptr);
736     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (aib_ptr);
737     
738     CPPUNIT_ASSERT(_FROM_BANK_->GetBalance() == -2500);
739     CPPUNIT_ASSERT(_TO_BANK_->GetBalance() == 3500);
740     
741 }
.fi
.SS "void MyTestCAse::nested_transaction_object_test ()"

.PP
Testing the library consistent behavior This test calls the nested function, where every thread transfer 3 unit in the nested transactions\&. Because this test in not threaded, the 3 level deep nesting transfer 3*20 = 60 from one object to the another object\&. 500 - 60 = 440 AND 500 + 60 = 560\&. 
.PP
Definition at line 787 of file MyTestCAse\&.cpp\&.
.PP
References client::_nesting_(), TM::_TX_EXIT(), a, tm, ulster_ptr, and unbl_ptr\&.
.PP
.nf
787                                                {
788     tm\&._TX_EXIT();
789     std::shared_ptr<OSTM> ulster_ptr(new ULSTER(500, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
790     std::shared_ptr<OSTM> unbl_ptr(new UNBL(600, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
791     std::shared_ptr<BANK> _FROM_BANK_;
792     std::shared_ptr<BANK> _TO_BANK_;
793     a->_nesting_(ulster_ptr, unbl_ptr, tm, 20);
794     _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (unbl_ptr);
795     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (ulster_ptr);
796     
797     CPPUNIT_ASSERT(_FROM_BANK_->GetBalance() == 440);
798     CPPUNIT_ASSERT(_TO_BANK_->GetBalance() == 560);
799     
800 }
.fi
.SS "void MyTestCAse::object_not_registered_throw_runtime_error ()"

.PP
The library function throws runtime error if the client application tries to load a working pointer from the library of a not registered pointer by the client application\&. Runtime error should be thrown\&. 
.PP
Definition at line 818 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), and tm\&.
.PP
.nf
818                                                           {
819     
820     std::shared_ptr<OSTM> not_registered_object(new BOA(300, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
821     std::shared_ptr<TX> tx = tm\&._get_tx();
822 
823     tx->load(not_registered_object);
824 }
.fi
.SS "void MyTestCAse::register_null_pointer_throw_runtime_error ()"

.PP
Definition at line 805 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), and tm\&.
.PP
.nf
805                                                           {
806     
807     std::shared_ptr<OSTM> null_ptr; 
808     std::shared_ptr<TX> tx = tm\&._get_tx();
809 
810     tx->_register(null_ptr);
811 }
.fi
.SS "void MyTestCAse::setUp ()\fC [inline]\fP"

.PP
Definition at line 108 of file MyTestCAse\&.h\&.
.PP
.nf
109   {
110       a = new client(1);
111       b = new client(1);
112       c = new client(1);
113 
114   }
.fi
.SS "void MyTestCAse::single_threaded_multiple_object_test ()"

.PP

.IP "3." 4
Single-threaded multiple object test\&. 
.PP

.PP
Definition at line 983 of file MyTestCAse\&.cpp\&.
.PP
References _collection_bject_(), TM::_TX_EXIT(), and tm\&.
.PP
.nf
983                                                      {
984     //one transaction multiple objects six object function
985     tm\&._TX_EXIT();
986     std::vector<std::shared_ptr < OSTM>>_customer_vec; 
987      for (int i = 0; i < 10; ++i) {
988         if (i % 6 == 0) {
989             std::shared_ptr<OSTM> sharedptr(new AIB(i, 10, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
990             _customer_vec\&.push_back(std::move(sharedptr));
991         } else if (i % 5 == 0) {
992             std::shared_ptr<OSTM> sharedptr(new BOI(i, 10, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
993             _customer_vec\&.push_back(std::move(sharedptr));
994         } else if (i % 4 == 0) {
995             std::shared_ptr<OSTM> sharedptr(new BOA(i, 10, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
996             _customer_vec\&.push_back(std::move(sharedptr));
997         } else if (i % 3 == 0) {
998             std::shared_ptr<OSTM> sharedptr(new SWBPLC(i, 10, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
999             _customer_vec\&.push_back(std::move(sharedptr));
1000         } else if (i % 2 == 0) {
1001             std::shared_ptr<OSTM> sharedptr(new ULSTER(i, 10, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
1002             _customer_vec\&.push_back(std::move(sharedptr));
1003         } else if (i % 1 == 0) {
1004             std::shared_ptr<OSTM> sharedptr(new UNBL(i, 10, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
1005             _customer_vec\&.push_back(std::move(sharedptr));
1006         }
1007     }
1008     std::shared_ptr<BANK> _one_, _two_, _three_, _four_, _five_, _six_;
1009     int loop = 5;
1010     int transferAmount = 1;
1011     int threadArraySize = 1; 
1012     std::thread thArray[threadArraySize];
1013 
1014     for (int i = 0; i < threadArraySize; ++i) { 
1015         thArray[i] = std::thread(&MyTestCAse::_collection_bject_, this, std::ref(_customer_vec),  std::ref(tm), transferAmount , loop);
1016     }
1017     
1018     for (int i = 0; i < threadArraySize; ++i) {
1019         thArray[i]\&.join();
1020     }
1021     
1022     _one_ = std::dynamic_pointer_cast<BANK> (_customer_vec[0]);
1023     _two_ = std::dynamic_pointer_cast<BANK> (_customer_vec[1]);
1024     _three_ = std::dynamic_pointer_cast<BANK> (_customer_vec[2]);
1025     _four_ = std::dynamic_pointer_cast<BANK> (_customer_vec[3]);
1026     _five_ = std::dynamic_pointer_cast<BANK> (_customer_vec[4]);
1027     _six_ = std::dynamic_pointer_cast<BANK> (_customer_vec[5]);
1028     
1029     CPPUNIT_ASSERT(_one_->GetBalance() == 15);
1030     CPPUNIT_ASSERT(_two_->GetBalance() == 15);
1031     CPPUNIT_ASSERT(_three_->GetBalance() == 15);
1032     CPPUNIT_ASSERT(_four_->GetBalance() == 15);
1033     CPPUNIT_ASSERT(_five_->GetBalance() == 15);
1034     CPPUNIT_ASSERT(_six_->GetBalance() == 15);
1035 }
.fi
.SS "void MyTestCAse::store_null_pointer_throw_runtime_error ()"

.PP
The test function throws runtime error if the client application tries to store the changed working pointer as a null pointer\&. Runtime error should be thrown\&. 
.PP
Definition at line 831 of file MyTestCAse\&.cpp\&.
.PP
References TM::_get_tx(), and tm\&.
.PP
.nf
831                                                        {
832     
833     std::shared_ptr<OSTM> null_ptr; 
834     std::shared_ptr<TX> tx = tm\&._get_tx();
835 
836     tx->store(null_ptr);
837 }
.fi
.SS "void MyTestCAse::tearDown ()\fC [inline]\fP"

.PP
Definition at line 116 of file MyTestCAse\&.h\&.
.PP
.nf
117   {
118       delete a;
119       delete b;
120       delete c;
121   }
.fi
.SS "void MyTestCAse::threaded_functionality_hundred_threads ()"
Testing the library consistent behavior This test transfer 1 unit by 100 threads = 100 *1 = 100 After transfer from account has -100, and to account has +100 
.PP
Definition at line 523 of file MyTestCAse\&.cpp\&.
.PP
References _two_account_transfer_(), TM::_TX_EXIT(), aib_ptr, boi_ptr, and tm\&.
.PP
.nf
523                                                        {
524     tm\&._TX_EXIT();
525     std::shared_ptr<BANK> _FROM_BANK_;
526     std::shared_ptr<BANK> _TO_BANK_;
527     
528     std::shared_ptr<OSTM> aib_ptr(new AIB(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
529     std::shared_ptr<OSTM> boi_ptr(new BOI(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
530     
531     int transferAmount = 1;
532     int threadArraySize = 100; 
533     std::thread thArray[threadArraySize];
534 
535     for (int i = 0; i < threadArraySize; ++i) {
536         thArray[i] = std::thread(&MyTestCAse::_two_account_transfer_, this, aib_ptr, boi_ptr, std::ref(tm), transferAmount);
537     }
538     
539     for (int i = 0; i < threadArraySize; ++i) {
540         thArray[i]\&.join();
541     }
542     
543     _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (boi_ptr);
544     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (aib_ptr);
545     
546     CPPUNIT_ASSERT(_FROM_BANK_->GetBalance() == 400);
547     CPPUNIT_ASSERT(_TO_BANK_->GetBalance() == 600);
548     
549 }
.fi
.SS "void MyTestCAse::threaded_functionality_hundred_threads_six_account ()"

.PP
Testing the library consistent behavior This test transfer 1 unit by 100 threads from five account to one account After transfer from account has - 100*1 from the accounts, and to account has +100*5\&. 
.PP
Definition at line 589 of file MyTestCAse\&.cpp\&.
.PP
References _six_account_transfer_(), TM::_TX_EXIT(), aib_ptr, boa_ptr, boi_ptr, swplc_ptr, tm, ulster_ptr, and unbl_ptr\&.
.PP
.nf
589                                                                    {
590     tm\&._TX_EXIT();
591     std::shared_ptr<BANK> _FROM_BANK_ONE,_FROM_BANK_TWO,_FROM_BANK_THREE, _FROM_BANK_FOUR, _FROM_BANK_FIVE;
592     std::shared_ptr<BANK> _TO_BANK_;
593     
594     std::shared_ptr<OSTM> aib_ptr(new AIB(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
595     std::shared_ptr<OSTM> boi_ptr(new BOI(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
596     std::shared_ptr<OSTM> boa_ptr(new BOA(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
597     std::shared_ptr<OSTM> ulster_ptr(new ULSTER(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
598     std::shared_ptr<OSTM> unbl_ptr(new UNBL(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
599     std::shared_ptr<OSTM> swplc_ptr(new SWBPLC(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
600     
601     int transferAmount = 1;
602     int threadArraySize = 100; 
603     std::thread thArray[threadArraySize];
604 
605     for (int i = 0; i < threadArraySize; ++i) {
606         thArray[i] = std::thread(&MyTestCAse::_six_account_transfer_, this, aib_ptr, boi_ptr, boa_ptr, ulster_ptr, unbl_ptr, swplc_ptr, std::ref(tm), transferAmount);
607     }
608     
609     for (int i = 0; i < threadArraySize; ++i) {
610         thArray[i]\&.join();
611     }
612     
613     _FROM_BANK_ONE = std::dynamic_pointer_cast<BANK> (boi_ptr);
614     _FROM_BANK_TWO = std::dynamic_pointer_cast<BANK> (boa_ptr);
615     _FROM_BANK_THREE = std::dynamic_pointer_cast<BANK> (ulster_ptr);
616     _FROM_BANK_FOUR = std::dynamic_pointer_cast<BANK> (unbl_ptr);
617     _FROM_BANK_FIVE = std::dynamic_pointer_cast<BANK> (swplc_ptr);
618     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (aib_ptr);
619     
620     CPPUNIT_ASSERT(_FROM_BANK_ONE->GetBalance() == 400);
621     CPPUNIT_ASSERT(_FROM_BANK_TWO->GetBalance() == 400);
622     CPPUNIT_ASSERT(_FROM_BANK_THREE->GetBalance() == 400);
623     CPPUNIT_ASSERT(_FROM_BANK_FOUR->GetBalance() == 400);
624     CPPUNIT_ASSERT(_FROM_BANK_FIVE->GetBalance() == 400);
625     CPPUNIT_ASSERT(_TO_BANK_->GetBalance() == 1000);
626     
627 }
.fi
.SS "void MyTestCAse::threaded_functionality_thousand_threads ()"

.PP
Testing the library consistent behavior This test transfer 1 unit by 1000 threads = 1000 *1 = 100 After transfer from account has -1000, and to account has +1000\&. 
.PP
Definition at line 556 of file MyTestCAse\&.cpp\&.
.PP
References _two_account_transfer_(), TM::_TX_EXIT(), aib_ptr, boi_ptr, and tm\&.
.PP
.nf
556                                                         {
557     tm\&._TX_EXIT();
558     std::shared_ptr<BANK> _FROM_BANK_;
559     std::shared_ptr<BANK> _TO_BANK_;
560     
561     std::shared_ptr<OSTM> aib_ptr(new AIB(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
562     std::shared_ptr<OSTM> boi_ptr(new BOI(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
563     
564     int transferAmount = 1;
565     int threadArraySize = 1000; 
566     std::thread thArray[threadArraySize];
567 
568     for (int i = 0; i < threadArraySize; ++i) {
569         thArray[i] = std::thread(&MyTestCAse::_two_account_transfer_, this, aib_ptr, boi_ptr, std::ref(tm), transferAmount);
570     }
571     
572     for (int i = 0; i < threadArraySize; ++i) {
573         thArray[i]\&.join();
574     }
575     
576     _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (boi_ptr);
577     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (aib_ptr);
578 
579     CPPUNIT_ASSERT(_FROM_BANK_->GetBalance() == -500);
580     CPPUNIT_ASSERT(_TO_BANK_->GetBalance() == 1500);
581     
582 }
.fi
.SS "void MyTestCAse::threaded_functionality_thousand_threads_six_account ()"

.PP
Testing the library consistent behavior This test transfer 1 unit by 1000 threads from five account to one account After transfer from account has - 1000*1 from the accounts, and to account has +1000*5\&. 
.PP
Definition at line 634 of file MyTestCAse\&.cpp\&.
.PP
References _six_account_transfer_(), TM::_TX_EXIT(), aib_ptr, boa_ptr, boi_ptr, swplc_ptr, tm, ulster_ptr, and unbl_ptr\&.
.PP
.nf
634                                                                     {
635     tm\&._TX_EXIT();
636     std::shared_ptr<BANK> _FROM_BANK_ONE,_FROM_BANK_TWO,_FROM_BANK_THREE, _FROM_BANK_FOUR, _FROM_BANK_FIVE;
637     std::shared_ptr<BANK> _TO_BANK_;
638     
639     std::shared_ptr<OSTM> aib_ptr(new AIB(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
640     std::shared_ptr<OSTM> boi_ptr(new BOI(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
641     std::shared_ptr<OSTM> boa_ptr(new BOA(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
642     std::shared_ptr<OSTM> ulster_ptr(new ULSTER(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
643     std::shared_ptr<OSTM> unbl_ptr(new UNBL(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
644     std::shared_ptr<OSTM> swplc_ptr(new SWBPLC(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
645     
646     int transferAmount = 1;
647     int threadArraySize = 1000; 
648     std::thread thArray[threadArraySize];
649 
650     for (int i = 0; i < threadArraySize; ++i) {
651         thArray[i] = std::thread(&MyTestCAse::_six_account_transfer_, this, aib_ptr, boi_ptr, boa_ptr, ulster_ptr, unbl_ptr, swplc_ptr, std::ref(tm), transferAmount);
652     }
653     
654     for (int i = 0; i < threadArraySize; ++i) {
655         thArray[i]\&.join();
656     }
657     
658     _FROM_BANK_ONE = std::dynamic_pointer_cast<BANK> (boi_ptr);
659     _FROM_BANK_TWO = std::dynamic_pointer_cast<BANK> (boa_ptr);
660     _FROM_BANK_THREE = std::dynamic_pointer_cast<BANK> (ulster_ptr);
661     _FROM_BANK_FOUR = std::dynamic_pointer_cast<BANK> (unbl_ptr);
662     _FROM_BANK_FIVE = std::dynamic_pointer_cast<BANK> (swplc_ptr);
663     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (aib_ptr);
664     
665     CPPUNIT_ASSERT(_FROM_BANK_ONE->GetBalance() == -500);
666     CPPUNIT_ASSERT(_FROM_BANK_TWO->GetBalance() == -500);
667     CPPUNIT_ASSERT(_FROM_BANK_THREE->GetBalance() == -500);
668     CPPUNIT_ASSERT(_FROM_BANK_FOUR->GetBalance() == -500);
669     CPPUNIT_ASSERT(_FROM_BANK_FIVE->GetBalance() == -500);
670     CPPUNIT_ASSERT(_TO_BANK_->GetBalance() == 5500);
671     
672 }
.fi
.SS "void MyTestCAse::TM_get_thread_map ()"

.PP
This function testing the returned map from the Transaction Manager class\&. 
.PP
Definition at line 903 of file MyTestCAse\&.cpp\&.
.PP
References TM::get_thread_Map(), and tm\&.
.PP
.nf
903                                   {
904     
905     std::map< std::thread::id, int > localMap;
906     std::map< std::thread::id, int > tmMap = tm\&.get_thread_Map();
907     
908     CPPUNIT_ASSERT(localMap == tmMap);
909 }
.fi
.SS "void MyTestCAse::two_object_transfer_complete ()"

.PP
Testing the library consistent behavior Transfer between two objects : the from object transfer 20 to the another object 500 - 20 = 480 AND 500 + 20 = 520\&. 
.PP
Definition at line 748 of file MyTestCAse\&.cpp\&.
.PP
References client::_two_account_transfer_(), TM::_TX_EXIT(), a, aib_ptr, boi_ptr, and tm\&.
.PP
.nf
748                                              {
749     tm\&._TX_EXIT();
750     std::shared_ptr<OSTM> aib_ptr(new AIB(100, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
751     std::shared_ptr<OSTM> boi_ptr(new BOI(200, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
752     std::shared_ptr<BANK> _FROM_BANK_;
753     std::shared_ptr<BANK> _TO_BANK_;
754     a->_two_account_transfer_(aib_ptr, boi_ptr, tm, 20);
755     _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (boi_ptr);
756     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (aib_ptr);
757     
758     CPPUNIT_ASSERT(_FROM_BANK_->GetBalance() == 480);
759     CPPUNIT_ASSERT(_TO_BANK_->GetBalance() == 520);
760     
761 }
.fi
.SS "void MyTestCAse::two_object_transfer_state_change ()"

.PP
This function proves the objects states must change from the base values\&. 
.PP
Definition at line 765 of file MyTestCAse\&.cpp\&.
.PP
References client::_two_account_transfer_(), TM::_TX_EXIT(), a, boa_ptr, swplc_ptr, and tm\&.
.PP
.nf
765                                                  {
766     tm\&._TX_EXIT();
767     std::shared_ptr<OSTM> boa_ptr(new BOA(300, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
768     std::shared_ptr<OSTM> swplc_ptr(new SWBPLC(400, 500, "Joe", "Blog", "High street, Kilkenny, Co\&.Kilkenny"));
769     std::shared_ptr<BANK> _FROM_BANK_;
770     std::shared_ptr<BANK> _TO_BANK_;
771     a->_two_account_transfer_(swplc_ptr, boa_ptr, tm, 20);
772     _FROM_BANK_ = std::dynamic_pointer_cast<BANK> (boa_ptr);
773     _TO_BANK_ = std::dynamic_pointer_cast<BANK> (swplc_ptr);
774 
775    
776     CPPUNIT_ASSERT(!(_FROM_BANK_->GetBalance() == 500));
777     CPPUNIT_ASSERT(!(_TO_BANK_->GetBalance() == 500));
778     
779 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBclient\fP* MyTestCAse::a\fC [private]\fP"

.PP
Definition at line 126 of file MyTestCAse\&.h\&.
.PP
Referenced by nested_transaction_object_test(), two_object_transfer_complete(), and two_object_transfer_state_change()\&.
.SS "std::shared_ptr<\fBOSTM\fP> MyTestCAse::aib_ptr"

.PP
Definition at line 66 of file MyTestCAse\&.h\&.
.PP
Referenced by complex_threaded_functionality_hundred_threads(), complex_threaded_functionality_ten_threads(), multi_threaded_multiple_object_exchange_test(), multi_threaded_single_object_test_with_ten_threads(), nested_hundred_thread_functionality(), nested_thousand_thread_functionality(), threaded_functionality_hundred_threads(), threaded_functionality_hundred_threads_six_account(), threaded_functionality_thousand_threads(), threaded_functionality_thousand_threads_six_account(), and two_object_transfer_complete()\&.
.SS "\fBclient\fP * MyTestCAse::b\fC [private]\fP"

.PP
Definition at line 126 of file MyTestCAse\&.h\&.
.SS "std::shared_ptr<\fBOSTM\fP> MyTestCAse::boa_ptr"

.PP
Definition at line 68 of file MyTestCAse\&.h\&.
.PP
Referenced by threaded_functionality_hundred_threads_six_account(), threaded_functionality_thousand_threads_six_account(), and two_object_transfer_state_change()\&.
.SS "std::shared_ptr<\fBOSTM\fP> MyTestCAse::boi_ptr"

.PP
Definition at line 67 of file MyTestCAse\&.h\&.
.PP
Referenced by complex_threaded_functionality_hundred_threads(), complex_threaded_functionality_ten_threads(), multi_threaded_multiple_object_exchange_test(), nested_hundred_thread_functionality(), nested_thousand_thread_functionality(), threaded_functionality_hundred_threads(), threaded_functionality_hundred_threads_six_account(), threaded_functionality_thousand_threads(), threaded_functionality_thousand_threads_six_account(), and two_object_transfer_complete()\&.
.SS "\fBclient\fP * MyTestCAse::c\fC [private]\fP"

.PP
Definition at line 126 of file MyTestCAse\&.h\&.
.SS "std::shared_ptr<\fBOSTM\fP> MyTestCAse::swplc_ptr"

.PP
Definition at line 69 of file MyTestCAse\&.h\&.
.PP
Referenced by threaded_functionality_hundred_threads_six_account(), threaded_functionality_thousand_threads_six_account(), and two_object_transfer_state_change()\&.
.SS "\fBTM\fP& MyTestCAse::tm = \fBTM::Instance\fP()"

.PP
Definition at line 65 of file MyTestCAse\&.h\&.
.PP
Referenced by _one_account_transfer_(), compare_Transaction_Manager_singleton_instance(), complex_threaded_functionality_hundred_threads(), complex_threaded_functionality_ten_threads(), decrease_nesting(), decrease_nesting_fail(), increase_nesting(), increase_nesting_fail(), multi_threaded_multiple_object_exchange_test(), multi_threaded_multiple_objects_test(), multi_threaded_single_object_test_with_ten_threads(), nested_hundred_thread_functionality(), nested_thousand_thread_functionality(), nested_transaction_object_test(), object_not_registered_throw_runtime_error(), register_null_pointer_throw_runtime_error(), single_threaded_multiple_object_test(), store_null_pointer_throw_runtime_error(), threaded_functionality_hundred_threads(), threaded_functionality_hundred_threads_six_account(), threaded_functionality_thousand_threads(), threaded_functionality_thousand_threads_six_account(), TM_get_thread_map(), two_object_transfer_complete(), and two_object_transfer_state_change()\&.
.SS "std::shared_ptr<\fBOSTM\fP> MyTestCAse::ulster_ptr"

.PP
Definition at line 70 of file MyTestCAse\&.h\&.
.PP
Referenced by nested_transaction_object_test(), threaded_functionality_hundred_threads_six_account(), and threaded_functionality_thousand_threads_six_account()\&.
.SS "std::shared_ptr<\fBOSTM\fP> MyTestCAse::unbl_ptr"

.PP
Definition at line 71 of file MyTestCAse\&.h\&.
.PP
Referenced by nested_transaction_object_test(), threaded_functionality_hundred_threads_six_account(), and threaded_functionality_thousand_threads_six_account()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for CppUnit test STM from the source code\&.
